---
title: "From metawebs to regional and local"
author: "L.A.S."
output: html_document
editor_options: 
  chunk_output_type: console
---

## Setup

- **I run the analysis chunk by chunk, not the whole Rmd** 

- So I set `eval=True` or `eval=False` to run a particular chunk or I run it interactively 


```{r setup, echo=FALSE }
load(".RData")

needed_packages <- c(
    "ggplot2"
  , "igraph"
  , "dplyr"
  , "stringr"
  , "devtools")

lapply(needed_packages, function(x) { if(!require(x,character.only = TRUE)){ install.packages(x) }} )

theme_set(theme_bw())

if( require(meweasmo) == FALSE)
  install_github("lsaravia/meweasmo")
if( require(multiweb) == FALSE)
  install_github("lsaravia/multiweb")

source("R/network_fun.r")

```

# Check the steady state of the model    

```{r checkSteadyState, eval=F,echo=F,message=T,warning=T}

source("R/network_fun.r")

redl <- meta 
sum(degree(redl,mode="in")==0) == websTbl$Basal[3]

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]

set.seed(2312)
#
# Testing if 500 time steps is enough to find equilibrium point
#
tf <- 2000
m <- rep(0.1,times=dimA)
e <- rep(0.3, times=dimA)
se <- rep(0.3, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 


tf <- 1500
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf1 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 

tf <- 1000
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf2 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 

tf <- 500
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf3 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 

#
# Kernel density based global two-sample comparison test 2d 
# to determine if the last 100 time steps have the same distribution of C and S 
# and therefore there is steady state
#
require(ks)
kde.test(AAdf3[,1:2],AAdf[,1:2])$pvalue
# [1] 0.9934058
kde.test(AAdf3[,1:2],AAdf1[,1:2])$pvalue
# [1] 0.7734683
kde.test(AAdf3[,1:2],AAdf2[,1:2])$pvalue
# [1] 0.6778419

AAdfTot <- bind_rows(AAdf %>% mutate(Sim="2000"), AAdf1 %>% mutate(Sim="1500"), AAdf2 %>% mutate(Sim="1000"), AAdf3 %>% mutate(Sim="500")) %>% mutate(model_type="Discrete")
ggplot(AAdfTot, aes(S,C,color=Sim))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))

#
# Testing for the CT model
#
tf <- 2000
m <- rep(0.1,times=dimA)
e <- rep(0.3, times=dimA)
se <- rep(0.3, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 1500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
AAdf1 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 1000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
AAdf2 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
AAdf3 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
AAdf4 <- tibble(C=AA$L[2:100]/ (AA$S[2:100])^2 ,S=AA$S[2:100]) %>% mutate(mC = mean(C), mS=mean(S)) 

require(ks)
kde.test(AAdf3[,1:2],AAdf[,1:2])$pvalue
#[1] 0.5309769
kde.test(AAdf3[,1:2],AAdf1[,1:2])$pvalue
# [1] 0.07517768
kde.test(AAdf3[,1:2],AAdf2[,1:2])$pvalue
# [1] 0.331641
##
# Testing the first 100 time steps against the last 100 of the '500' simulation
kde.test(AAdf4[,1:2],AAdf3[,1:2])$pvalue
# [1] 0.001407754

AAdfTot <- bind_rows(AAdfTot, 
                     bind_rows(AAdf %>% mutate(Sim="2000"), AAdf1 %>% mutate(Sim="1500"), AAdf2 %>% mutate(Sim="1000"), AAdf3 %>% mutate(Sim="500")) %>% mutate(model_type="Continuous")
                     )
ggplot(AAdfTot, aes(S,C,color=Sim))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)
ggsave("Figures/Metaweb_SteadyState_byModel.pdf",width=8,height=5,units="in",dpi=600)




#
# Testing if there are difference with different m/e 
#

AAdf <- AAdf %>% mutate(e=0.2)

tf <- 500
m <- rep(0.2,times=dimA)
e <- rep(0.8, times=dimA)
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),Sim="500",e=0.8) )

ggplot(AAdf %>% filter(Sim=="500"), aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))

tf <- 500
m <- rep(0.02,times=dimA)
e <- rep(0.08, times=dimA)
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),Sim="500",e=0.08) )

ggplot(AAdf %>% filter(Sim=="500"), aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))

tf <- 500
m <- rep(0.02,times=dimA)
e <- rep(0.02, times=dimA)
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),Sim="500",e=0.02) )

ggplot(AAdf %>% filter(Sim=="500"), aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))


tf <- 500
m <- rep(0.02,times=dimA)
e <- rep(0.01, times=dimA)
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),Sim="500",e=0.01) )

ggplot(AAdf %>% filter(Sim=="500"), aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))

```




# Simulate a grid of parameters to select the best options


```{r makeSimulations150000, eval=TRUE,echo=F,message=T,warning=T}


redl <- meta 
sum(degree(redl,mode="in")==0) == websTbl$Basal[3]

A <- get.adjacency(redl,sparse=F)
dimA <- nrow(A)

# Simulate a grid of parameters to select the best options using latin hypercubic sampling
#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
#
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)
simMetaWebAssembly <- tibble()
# simulations with probability of secondary extinction == 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2, 150000, par_ranges,A )

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction != 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A) %>% mutate(model_type="Discrete") 

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")


# simulations with probability of secondary extinction != 1
#
# Continuous time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A, 1 ) %>% mutate(model_type="Continuous") 

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction == 0
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  50000, par_ranges,A )

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# Set the type of models according to probability of secoondary extinction
#
#simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ), model_type=ifelse(is.na(model_type), "Discrete", "Continuous"))
knitr::kable(simMetaWebAssembly %>% group_by(model,model_type) %>% summarise(n=n()))

ggplot(simMetaWebAssembly, aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Connectance,color=Network),size=0.3) + coord_cartesian(ylim=c(0,0.1)) + facet_wrap(model_type ~ model)

ggplot(simMetaWebAssembly, aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Links,color=Network),size=0.3) + coord_cartesian(ylim=c(0,3000)) + facet_wrap(~model)

ggplot(simMetaWebAssembly %>% filter(model_type=="Discrete"), aes(S,C,color=model))+ geom_point(size=.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Connectance,color=Network),size=0.4) + coord_cartesian(ylim=c(0,0.1)) + scale_color_brewer(palette= "Dark2",name="")#, labels=c("Fixed Sec.Ext.", "Potter","Meta", "No Sec.Ext.", "Prob. Sec.Ext.","Weddell" ))  

ggplot(simMetaWebAssembly %>% filter(model=="Prob"), aes(S,C,color=model_type))+ geom_point(size=.1,alpha=0.5) + theme_bw() + coord_cartesian(ylim=c(0,0.1)) + scale_color_brewer(palette= "Dark2",name="")#, labels=c("Fixed Sec.Ext.", "Potter","Meta", "No Sec.Ext.", "Prob. Sec.Ext.","Weddell" ))  
ggsave("Figures/Metaweb_Continuous_Discrete.pdf",width=8,height=5,units="in",dpi=600)


ggplot(simMetaWebAssembly %>% filter(model=="Prob"), aes(S,C,color=model_type))+ geom_point(size=.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Connectance,color=Network),size=0.4) + coord_cartesian(ylim=c(0,0.1)) + scale_color_brewer(palette= "Dark2",name="")#, labels=c("Fixed Sec.Ext.", "Potter","Meta", "No Sec.Ext.", "Prob. Sec.Ext.","Weddell" ))  
rm(sim,par_ranges,AAdf,AAdf1,AAdf2,AAdf3,AAdf4,AAdfTot,f)
save.image()
```

* The discrete time and continuous time models give the same results, this is a verification that the models are well implemented and that the timmings of events have no influence on the results. So we keep using the discrete time model.  

## Make the fit finding the parameters with less distance to empirical networks

```{r fitMetaWebPC50002, eval=FALSE,echo=F,message=T,warning=T}


#
# Potter Cove
#
# Use this tolerance = tol to display a more detailed plot 

tol <- .1
sel <- simMetaWebAssembly %>% mutate(alpha=m/a) %>% filter(S>websTbl$Size[1]*(1-tol),S<websTbl$Size[1]*(1+tol), se>0 & se<1) %>% arrange(S)
sel <- bind_rows(sel, simMetaWebAssembly %>% mutate(alpha=m/a) %>% filter(S>websTbl$Size[1]*(1-tol),S<websTbl$Size[1]*(1+tol), se==0) %>% arrange(S))
sel <- bind_rows(sel, simMetaWebAssembly %>% mutate(alpha=m/a) %>% filter(S>websTbl$Size[1]*(1-tol),S<websTbl$Size[1]*(1+tol), se==1) %>% arrange(S))
# ggplot(sel, aes(S,C, color=model)) + geom_point(alpha=0.5,size=0.1) + theme_bw() + geom_point(data=websTbl %>% filter(Network=="local"), aes(Size,Connectance,color=Network))  + scale_color_viridis_d()

#
# Fit using the distance to S and C
#
sel <- sel %>% group_by(model) %>% mutate(distance = sqrt(((websTbl$Size[1] - S)/websTbl$Size[1])^2 +  ((websTbl$Connectance[1] - C )/websTbl$Connectance[1])^2), min_dist = (distance == min(distance))) %>% arrange(distance)
sel %>% group_by(model) %>% filter(min_dist)

fittedMetaWeb <- sel %>% filter(min_dist) %>% mutate(Network="Potter",fit_type="S-C")

ggplot(sel, aes(S,C, color=min_dist)) + geom_point(alpha=0.5) + theme_bw() + geom_point(data=websTbl %>% filter(Network=="local"), aes(Size,Connectance,color=Network)) + facet_wrap(~model)  + scale_color_viridis_d(name="",labels=c("Simulations", "Empirical (Potter)","Fit" ))
ggsave("Figures/Metaweb_fit_Potter_byModel.pdf",width=8,height=5,units="in",dpi=600)

# Weddell Sea
#
tol <- .1
sel <- simMetaWebAssembly %>% mutate(alpha=m/a) %>% filter(S>websTbl$Size[2]*(1-tol),S<websTbl$Size[2]*(1+tol), se>0 & se<1) %>% arrange(S)
sel <- bind_rows(sel, simMetaWebAssembly %>% mutate(alpha=m/a) %>% filter(S>websTbl$Size[2]*(1-tol),S<websTbl$Size[2]*(1+tol), se==0) %>% arrange(S))
sel <- bind_rows(sel, simMetaWebAssembly %>% mutate(alpha=m/a) %>% filter(S>websTbl$Size[2]*(1-tol),S<websTbl$Size[2]*(1+tol), se==1) %>% arrange(S))

# Restricting L by tol=10% result in no records selected
#
sel %>% filter(L>websTbl$Links[2]*(1-tol),L<websTbl$Links[2]*(1+tol), se>0 & se<1) %>% arrange(S)

#
# Fit using the distance to S and C
#
sel <- sel  %>% group_by(model) %>% mutate(distance = sqrt(((websTbl$Size[2] - S)/websTbl$Size[2])^2 + ((websTbl$Connectance[2] - C )/websTbl$Connectance[2])^2), min_dist = (distance == min(distance))) %>% arrange(distance)
sel %>% filter(min_dist)
fittedMetaWeb <- bind_rows(fittedMetaWeb, sel %>% filter(min_dist) %>% mutate(Network="Weddell",fit_type="S-C"))

ggplot(sel, aes(S,C, color=min_dist)) + geom_point(alpha=0.5) + theme_bw() + geom_point(data=websTbl %>% filter(Network=="Regional"), aes(Size,Connectance,color=Network)) + facet_wrap(~model)  + scale_color_viridis_d(name="",labels=c("Simulations", "Empirical (Weddell)","Fit" ))
ggsave("Figures/Metaweb_fit_Weddell_byModel.pdf",width=8,height=5,units="in",dpi=600)



knitr::kable(fittedMetaWeb %>% dplyr::select( Network,  everything(), -min_dist) %>% arrange(Network))

rm(X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ravg,sel)
save.image()

```


* Fit of Metaweb model by variant usin C and S


|Network |         m|         a|         S|         L|         C|        se|model     |     alpha|  distance|fit_type |
|:-------|---------:|---------:|---------:|---------:|---------:|---------:|:---------|---------:|---------:|:--------|
|Potter  | 0.1089198| 0.3126573|  93.00990|  325.8119| 0.0376624| 0.4051581|Prob      | 0.3483679| 0.0022872|S-C      |
|Potter  | 0.0358264| 0.1225775|  92.88119|  323.3861| 0.0374857| 1.0000000|Fixed     | 0.2922756| 0.0027351|S-C      |
|Potter  | 0.0188347| 0.0825856|  93.39604|  328.4158| 0.0376502| 0.0000000|No SecExt | 0.2280627| 0.0046872|S-C      |
|Weddell | 0.0124007| 0.0106208| 419.51485| 2415.0990| 0.0137227| 0.0000000|No SecExt | 1.1675867| 0.3691503|S-C      |
|Weddell | 0.0181701| 0.0120232| 453.00990| 2963.9604| 0.0144430| 1.0000000|Fixed     | 1.5112539| 0.4406999|S-C      |
|Weddell | 0.0208599| 0.0122194| 466.19802| 3147.9604| 0.0144840| 0.3841983|Prob      | 1.7071073| 0.4484365|S-C      |


*  Using number of species, number of links the results are similar (Deleted from the code)

|Network |         m|         a|         S|         L|         C|        se|model     |     alpha|  distance|fit_type |
|:-------|---------:|---------:|---------:|---------:|---------:|---------:|:---------|---------:|---------:|:--------|
|Potter  | 0.2084439| 0.4719407|  92.83168|  325.3168| 0.0377498| 0.8194494|Prob      | 0.4416740| 0.0020557|S-L      |
|Potter  | 0.0761438| 0.2346869|  93.17822|  324.6337| 0.0373908| 1.0000000|Fixed     | 0.3244487| 0.0022233|S-L      |
|Potter  | 0.0188347| 0.0825856|  93.39604|  328.4158| 0.0376502| 0.0000000|No SecExt | 0.2280627| 0.0113402|S-L      |
|Weddell | 0.0200153| 0.0154432| 399.28713| 2357.1980| 0.0147851| 0.0000000|No SecExt | 1.2960572| 0.2500339|S-L      |
|Weddell | 0.0248818| 0.0193673| 398.34653| 2374.5941| 0.0149647| 0.7391516|Prob      | 1.2847377| 0.2593474|S-L      |
|Weddell | 0.0370119| 0.0274324| 397.75248| 2444.2772| 0.0154499| 1.0000000|Fixed     | 1.3492030| 0.2944393|S-L      |


# Make simulations with fitted parameters with S-C method

* As connectivity is determines most of other network properties we fit by connectivity and number of species

```{r fitMetaWebSims, eval=FALSE,echo=F,message=T,warning=T}

# Model with probability of secundary extinction se>0 & se<1
#
# Potter
#
tf <- 500
set.seed(1110) 
f <- fittedMetaWeb %>% filter(Network=="Potter")
mm <- rep(f$m[1],nrow(A))
aa <- rep(f$a[1],nrow(A))
se <- rep(f$se[1],nrow(A))
AA <- metaWebNetAssembly(A,mm,aa,se,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))

# Running averages
ravg <- tibble()
ravg <- bind_rows( ravg, plot_NetAssemblyModel_eqw(AA,50,"Figures/PotterCove_Meta-webSim_avg_Prob.pdf",websTbl[1,]) %>% mutate(Network = "Potter"))

# Time series plot
plot_NetAssemblyModel(AA,300,"Figures/PotterCove_Meta-webSim_ts_Prob.pdf",websTbl[1,])

#
# Weddell 
#

f <- fittedMetaWeb %>% filter(Network=="Weddell")

# Modelo Prob
# 
tf <- 500
set.seed(1110)
mm <- rep(f$m[3],nrow(A))
aa <- rep(f$a[3],nrow(A))
se <- rep(f$se[3],nrow(A))
AA <- metaWebNetAssembly(A,mm,aa,se,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
ravg <- bind_rows( ravg, plot_NetAssemblyModel_eqw(AA,50,"Figures/Weddell_Meta-webSim_avg_Prob.pdf",websTbl[2,]) %>% mutate(Network = "Weddell"))
plot_NetAssemblyModel(AA,300,"Figures/Weddell_Meta-webSim_ts_Prob.pdf",websTbl[2,])




rm(X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,ravg,dfA,dtot,dtot1,cl,sel,redl,e,ee,ext,aa,m,mig,mm,se,colTL,cn,colnet)
save.image()

  # Plot of five simulations 
#
gg <- plot_NetAssemblyModel(AA,100)

# Plot of S and C for Weddell 
#
require(cowplot)
g3 <- plot_grid(gg[[1]],gg[[3]],labels = c("A","B"),align = "h")
save_plot("Figures/Weddell_Meta-webSim_SC.png",g3,base_width=8,base_height=5,dpi=300)


```



# Local web (Potter Cove) compared to  metaWeb assembly model

* Ideas to compare is to select the simulations with the same C or Same S ?????

```{r PotterGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Read data and trim species names to avoid duplicates 
#
# dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
# dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))
# 
# #
# # Select meta web 
# #
# dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
# redl <- graph_from_edgelist(dtot1, directed  = T)
# # Delete cannibalistic 
# redl <- simplify(redl)
# sum(degree(redl,mode="in")==0)
# 
redl <- meta 
sum(degree(redl,mode="in")==0) == websTbl$Basal[3]

A <- get.adjacency(redl,sparse=F)
dim(A)                             

#
# Select Local food web 
# 
redl <- pott 
sum(degree(redl,mode="in")==0) == websTbl$Basal[1]

# dtot1 <- as.matrix(dtot %>% filter(Network=="Local") %>% dplyr::select(Prey_name,Predator_name))
# redl <- graph_from_edgelist(dtot1, directed  = T)

#
# Calculate Trophic Position
#
require(NetIndices)
TL <-TrophInd(get.adjacency(redl,sparse=F),Dead=c("Fresh detritus","Aged detritus","Necromass"))

#
# Compare modularity 
#
require(tictoc)
fittedMetaWeb$m[1]
fittedMetaWeb$a[1]

tic()
tbl <- calc_modularity_metaWebAssembly(redl, A, fittedMetaWeb$m[1],fittedMetaWeb$a[1],1000,TL)
toc()
sim <- tbl$sim
tblMdlWeb <- tbl$su %>% mutate(Network="Potter") %>% inner_join(dplyr::select(websTbl,Size:Modularity), by="Network")

#
# Calculate z-score of modularity
#
tblMdlWeb <- tblMdlWeb %>% mutate(zMO= (Modularity- mdlMO)/MOsd, zGR=(Groups-mdlGR)/(GRhigh-GRlow)*2)

websAssemblyModel <- dplyr::select(tblMdlWeb,Network:Modularity,mdlCC:zTI,zMO:zGR)

#
# Correct the calculation of z-score
#
websAssemblyModel$mdlMO[2] <- with(tblMdlWeb,mdlMO)
websAssemblyModel$zMO[2] <- with(tblMdlWeb, (Modularity- mdlMO)/MOsd)
rm(tbl)

websAssemblyModelSim <-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network="Potter"))  
save.image()



```



# Regional web (Weddell) compared to  metaWeb assembly model 

```{r WeddellGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Select "Regional" food web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Regional") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
redl <- simplify(redl)


require(NetIndices)
TL<-TrophInd(get.adjacency(redl,sparse=F),Dead=c("Detritus","Necromass"))

#
# Compare modularity 
#
require(tictoc)
m <- 0.084 
a <- 0.076
tic()
tbl <- calc_modularity_metaWebAssembly(redl, A, m,a,1000,TL)
toc()
sim <- tbl$sim

tblMdlWeb <- tbl$su %>% mutate(Network="Weddell") %>% inner_join(dplyr::select(websTbl,Size:Modularity), by="Network")

#
# Calculate z-score of modularity
#
tblMdlWeb <- tblMdlWeb %>% mutate(zMO= (Modularity- mdlMO)/MOsd, zGR=(Groups-mdlGR)/(GRhigh-GRlow)*2)

websAssemblyModel <- bind_rows(websAssemblyModel, dplyr::select(tblMdlWeb,Network:Modularity,mdlCC:zTI,zMO:zGR))

#
# Correct the calculation of z-score
#
# websAssemblyModel$mdlMO[1] <- with(tblMdlWeb,mdlMO)
# websAssemblyModel$zMO[1] <- with(tblMdlWeb, (Modularity- mdlMO)/MOsd)
websAssemblyModelSim <-  sim %>% mutate(Network="Weddell")


#
# Plots of the distribution of simulated indices
#
require(RColorBrewer)
col <- brewer.pal(8,"Dark2")
col <- c("#0097A7","#448AFF","#212121")
dat <- websAssemblyModel %>% filter(Network=="Regional") %>% rename(modularity=Modularity) %>% bind_cols(websTbl %>% filter(Network=="Weddell") %>% select(Q,mTI))

sim <- websAssemblyModelSim %>% filter(Network=="Weddell")
names(dat)
names(sim)
#
# Plot for the figure 1 
#
p <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_classic() + xlab("Network metric")
p + geom_segment(data=dat,aes(x=Q+0.4,xend=Q+0.4, y=30, yend = 0), colour=col[2], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[3], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[3], size=1, linetype=1 )


p1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=SWness, y=85, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=55, yend = 0), colour=col[2], size=1, linetype=1 )


p2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=Q, y=30, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[2], size=1, linetype=1 )

p3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=mTI, y=25, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=18, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=18, yend = 0), colour=col[2], size=1, linetype=1 )


p4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
    geom_segment(data=dat,aes(xend=modularity, y=25, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=18, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=18, yend = 0), colour=col[2], size=1, linetype=1 )


dat <- websAssemblyModel %>% filter(Network=="Local") %>% rename(modularity=Modularity) %>% bind_cols(websTbl %>% filter(Network=="Potter") %>% select(Q,mTI))

sim <- websAssemblyModelSim %>% filter(Network=="Potter")

q1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=SWness, y=185, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=120, yend = 0), colour=col[2], size=1, linetype=1 )


q2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=Q, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )

q3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=mTI, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )


q4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
    geom_segment(data=dat,aes(xend=modularity, y=24, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=16, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=16, yend = 0), colour=col[2], size=1, linetype=1 )


require(cowplot)
p5 <- plot_grid(q1+xlab(""),q2+ylab("")+xlab(""),q3+ylab("")+xlab(""),q4+ylab("")+xlab(""),
                p1,p2+ylab(""),p3+ylab(""),p4+ylab(""),align = "h",nrow=2,labels = c("A","","","","B"))
save_plot("Figures/globProp_assembly_ByNetwork.png",p5,base_width=8,base_height=5,dpi=600)



save.image()
```


# Motif Potter Cove compared to  metaWeb assembly model 

```{r PotterMotifMetaWebAssembly, eval=F,echo=F,message=T,warning=T}


#sourceCpp("src/NetAssemblyFromMetaWeb.cpp")

#
# Read data and trim species names to avoid duplicates 
#
dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))

#
# Select meta web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
# Delete cannibalistic 
redl <- simplify(redl)
sum(degree(redl,mode="in")==0)

A <- get.adjacency(redl,sparse=F)
dim(A)                             

#
# Select Local food web 
# 

dtot1 <- as.matrix(dtot %>% filter(Network=="Local") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)

#
# Motif
#
mot <- triad_census(redl)

mot[4] # Exploitative competition
mot[5] # Apparent competition
mot[6] # Tri-trophic chain
mot[9] # Omnivory

#FreqMotif <- data.frame(Network="Local",t(mot))

set.seed(123)
m <- 0.023
a <- 0.094
motif_metaWeb <- calc_motif_metaWebAssembly(redl, A, m,a,1000)

motif_metaWeb <- motif_metaWeb %>% mutate(Network="Local")


save.image()

```


# Motif Weddell compared to  metaWeb assembly model 

```{r WeddellMotifMetaWebAssembly, eval=FALSE,echo=F,message=T,warning=T}


#
# Select "Regional" food web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Regional") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
redl <- simplify(redl)


#
# Motif
#
set.seed(123)

m <- 0.084 
a <- 0.076
m_metaWeb <- calc_motif_metaWebAssembly(redl, A, m,a,1000)

motif_metaWeb <- bind_rows(motif_metaWeb, m_metaWeb %>% mutate(Network="Regional"))

rm(m_metaWeb)
save.image()


select(motif_metaWeb, explComp,EClow,EChigh)
select(motif_metaWeb, apprComp,AClow,AChigh,zAC)
select(motif_metaWeb, triTroph,TTlow,TThigh,zTT)
select(motif_metaWeb, omnivory,OMlow,OMhigh,zOM)

# Generate tables for the manuscript
#
#
require(pander)
panderOptions('table.split.table',Inf)
panderOptions('table.style', 'multiline')

webs_tmp <- inner_join(websAssemblyModel,dplyr::select(websTbl,Q,mTI,Network), by="Network")

pandoc.table(t(webs_tmp %>% dplyr::select(Network,SWness,SWnessCI,zQ,zTI,zMO,zGR,mTI) %>% mutate_if(is.numeric, round, digits=4)))


pandoc.table(t(webs_tmp %>% dplyr::select(Network,Q,Qlow,Qhigh,mTI,TIlow,TIhigh,Modularity, MOlow,MOhigh) %>% mutate_if(is.numeric, round, digits=4)))

pandoc.table(t(motif_metaWeb %>% rename(EC=explComp,AC=apprComp,TT=triTroph,OM=omnivory) %>%
                 dplyr::select(Network,EC,EClow,EChigh,zEC,AC,AClow,AChigh,zAC,TT,TTlow,TThigh,zTT,OM,OMlow,OMhigh,zOM) %>% mutate_if(is.numeric, round, digits=2)))


# Plot of random z-score motif normalized
#
#

require(tidyr)
names(motif)
pFM1 <- motif %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,value,zEC:zOM) %>% mutate(type="Random z-score")
pFM1$Network <- factor(pFM1$Network)
levels(pFM1$Network) <- c("Potter Cove","Meta-web","Weddell Sea")

# Normalize z-scores
#
pFM1 <- pFM1 %>% group_by(Network) %>% mutate(normZ=value/sum(sqrt(value^2)))
g1 <- ggplot(pFM1,aes(x=Network,y=normZ,fill=motif)) + geom_bar(stat="identity",position=position_dodge()) +
   scale_fill_brewer(palette = "Paired",breaks=c("zAC","zEC","zOM","zTT"),name="Motif\nZ-score",   labels=c("Apparent\ncompetition","Exploitative\ncompetition","Omnivory", "Tri-trophic\nchain")) + guides(fill=FALSE) +
   xlab("") + ylab("") + theme_bw() + scale_x_discrete(limits=c("Potter Cove","Weddell Sea","Meta-web")) + expand_limits(y=c(0.8,-0.35)) #+ theme(legend.position="bottom")

# Add asteriscs to significative motifs

sig_lbl <- pFM1 %>% mutate(normZ=ifelse(motif=="zTT", normZ-0.05,normZ+0.05) )
g1 <- g1 + geom_text(data = sig_lbl, label = "*",position=position_dodge(width=0.9))

# Plot of assembly motifs normalized 
#
names(motif_metaWeb)
pFM2 <- motif_metaWeb %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,value,zEC:zOM) %>% mutate(type="Assembly z-score", Network=factor(Network))

levels(pFM2$Network) <- c("Potter Cove","Weddell Sea")

pFM2 <- pFM2 %>% group_by(Network) %>% mutate(normZ=value/sum(sqrt(value^2)))

g2 <- ggplot(pFM2,aes(x=Network,y=normZ,fill=motif)) + geom_bar(stat="identity",position=position_dodge()) +
     scale_fill_brewer(palette = "Paired",breaks=c("zAC","zEC","zOM","zTT"),name="Motif\nZ-score",   labels=c("Apparent\ncompetition","Exploitative\ncompetition","Omnivory", "Tri-trophic\nchain")) + 
   xlab("") + ylab("") + theme_bw() + scale_x_discrete(limits=c("Potter Cove","Weddell Sea","Meta-web")) + expand_limits(y=c(0.8,-0.35)) #+ theme(legend.position="bottom")

# Add asteriscs to significative motifs
sig_lbl <- pFM2 %>% mutate(normZ=ifelse(Network=="Potter Cove" & motif=="zAC",normZ+0.05,
                                        ifelse(Network=="Weddell Sea" & (motif=="zTT" | motif=="zOM"),normZ-0.05,NA)))  

g2 <- g2 + geom_text(data = sig_lbl, label = "*",position=position_dodge(width=0.9)) 

g2
require(cowplot)
g3 <- plot_grid(g1,g2,labels = c("A","B"),align = "h",rel_widths=c(.9,1.2))
g3
save_plot("Figures/Motif_Zs_ByNetwork.png",g3,base_width=8,base_height=5,dpi=600)



```

# Topologcal roles with meta-web assembly model 

```{r MetaWebTopologicalRoles, eval=FALSE,echo=F,message=T,warning=T}

# Check the correct meta-web adjacency matrix is loaded

dim(A)==c(859,859)

#
# 500 time steps 
#
tf <- 500
set.seed(1234)

# Weddell Sea 
#
#
m <- 0.084 
a <- 0.076
tf <- 531
AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
dfA$S[tf-200]
plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

g <- graph_from_adjacency_matrix( AA$A, mode  = "directed")

# Select only a connected subgraph graph 
#
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
vcount(g)
modulos<-cluster_spinglass(g)

topoRoles_metaWebAssembly <- calc_avg_topological_roles(g,"Weddell",10)   # 30 simulations are enough to obtain stable topological roles

# Initialize hub_conn
hub_conn_Assembly <- data.frame()

# Plot and clasify topological roles
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(topoRoles_metaWebAssembly,g,modulos) %>% mutate(Network="Weddell"))

plotTopoRolesByTLByMod("","Weddell","",modulos,hub_conn_Assembly,"",g)


# Potter Cove Simulations
#
#

set.seed(123)
m <- 0.023
a <- 0.094
tf <- 546

AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))

plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

AA$S[tf]

g <- graph_from_adjacency_matrix( AA$A*1, mode  = "directed")
# Add Names
#V(g)$label <- rownames(A)

# Select only a connected subgraph graph 
#
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
#plot(g,edge.arrow.size=.4,edge.color="orange", vertex.color="gray50",vertex.size=3,layout=layout_with_fr)
vcount(g)
sum(degree(g,mode="in")==0)
V(g)[degree(g,mode="in")==0]$label

modulos<-cluster_spinglass(g)

tR <- calc_avg_topological_roles(g,"Potter",10)
topoRoles_metaWebAssembly <- bind_rows(topoRoles_metaWebAssembly,tR )


# Plot and clasify topological roles
#
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(tR,g,modulos) %>% mutate(Network="Potter"))

plotTopoRolesByTLByMod("","Potter","",modulos,hub_conn_Assembly,"",g)

save.image()

# Topological Roles proportions test and plot
#
#
names(hub_conn)


tbl <- table(hub_conn$Network,hub_conn$type)

tbl1 <- table(hub_conn_Assembly$Network,hub_conn_Assembly$type)
tbl1 <- rbind(tbl,tbl1) 
tbl1 <- tbl1[c(2,4,5),]
class(tbl1) <- "table"

chisq.test(tbl1,simulate.p.value = TRUE, B=10000)

require(ggplot2)
require(scales)
df1 <- data.frame(tbl1) 
names(df1) <- c("Network","Rol","count")
df1 <- filter(df1,count!=0)
df1 <- df1 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df1$Network <- factor(df1$Network, levels=c("Potter","Weddell","Meta")) 

levels(df1$Network) <- c("Potter Cove\nModel","Weddell Sea\nModel","Meta-web")


gP1 <- ggplot(df1,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")


# Proportion of topo roles of the real networks
#
df2 <- data.frame(tbl,stringsAsFactors = FALSE)
names(df2) <- c("Network","Rol","count")
df2 <- filter(df2,count!=0)
df2 <- df2 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df2$Network <- factor(df2$Network, levels=c("Local","Regional","Meta")) 
levels(df2$Network) <- c("Potter Cove","Weddell Sea","Meta-web")

gP2 <- ggplot(df2,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")

legend_b <- get_legend(gP2 + theme(legend.position="bottom"))

require(cowplot)
gP3 <- plot_grid(gP2,gP1,labels = c("A","B"),align = "h")
gP3 <- plot_grid( gP3, legend_b, ncol = 1, rel_heights = c(1, .05))
save_plot("Figures/PropRoles_ByNetwork_Model.png",gP3,base_width=8,base_height=5,dpi=600)
#ggsave("Figures/PropMotif_Roles_ByNetwork.png",width=8,height=5,units="in",dpi=600)

save.image()
```

