---
title: "From metawebs to regional and local"
author: "L.A.S."
output: html_document
editor_options: 
  chunk_output_type: console
---

## Setup

```{r setup, eval=T,echo=FALSE }
load(".RData")
oldcd <-getwd()
require(ggplot2)
require(igraph)
require(dplyr)
require(stringr)
require(devtools)
require(MetaWebAssemblyModels)
source("R/network_fun.r")

```

# Fitting metaWeb assembly models to Potter Cove   

```{r fitMetaWebPC, eval=F,echo=F,message=T,warning=T}

source("R/network_fun.r")
# load_all('MetaWebAssemblyModels')
# install_local('../MetaWebAssemblyModels')
# sourceCpp("src/NetAssemblyFromMetaWeb.cpp")

#
# Read data and trim species names to avoid duplicates 
#
dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))

#
# Select food web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
# Delete cannibalistic 
redl <- simplify(redl)
sum(degree(redl,mode="in")==0)

A <- get.adjacency(redl,sparse=F)
dim(A)

#
# Testing if 500 time steps is enough to find equilibrium point
#
tf <- 2000
AA <- metaWebNetAssembly(A,0.05,1,0.2,tf)
plot_NetAssemblyModel(AA,400)
plot_NetAssemblyModel_eqw(AA,100)
tf <- 500
AA <- metaWebNetAssembly(A,0.05,1,0.2,tf)
plot_NetAssemblyModel_eqw(AA,100)



# Simulate a grid of parameters to select the best options
#
#

# Combine parameters
arguments <- expand.grid(m = seq(from=0.01,to=0.1,by=0.001), a = seq(from=0.01,to=0.1,by=0.001))
simMetaWebAssembly <- data.frame()
# repeat ten times
arguments<- bind_rows(arguments,arguments,arguments,arguments,arguments,arguments,arguments,arguments,arguments,arguments)
tf <- 500
sim <- data.frame()
require(doParallel)
require(tictoc)
cn <-detectCores()
#  cl <- makeCluster(cn,outfile="foreach.log") # Logfile to debug 
cl <- makeCluster(cn)
registerDoParallel(cl)
nsim <- dim(arguments)[1]
tic()
sim <- foreach(i=1:nsim,.combine='rbind',.inorder=FALSE,.packages='MetaWebAssemblyModels') %dopar% 
{
  mm <- arguments[i,1]
  aa <- arguments[i,2]
  AA <- metaWebNetAssembly(A,mm,1,aa,tf)
  dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
  data.frame(m=mm,a=aa, S=mean(dfA$S),L=mean(dfA$L),C=mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
}
toc()
stopCluster(cl)
simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")
simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")

# To select the parameters I lowered the tolerance until there is only one value or few values
#
# Potter Cove
#

tol <- .2
simMetaWebAssembly %>% group_by(m,a) %>% summarize(S=mean(S),L=mean(L),C=mean(C)) %>% mutate(alpha=m/a) %>% filter(L>309*(1-tol),L<309*(1+tol),S>91*(1-tol),S<91*(1+tol)) %>% arrange(desc(L))
# Simulations
#       m     a        S        L         C    alpha
# 4 0.019  0.08 108.0955 249.9427 0.02139875 0.2375
# 7 0.023 0.096 109.0323 247.8472 0.02086496 0.2395833
# 10 0.023 0.094 109.1362 247.9425 0.02079193 0.2446809

# Weddell Sea
#
tol <- .128
simMetaWebAssembly %>% group_by(m,a) %>% summarize(S=mean(S),L=mean(L),C=mean(C)) %>% mutate(alpha=m/a) %>% filter(L>1908*(1-tol),L<1908*(1+tol), S>436*(1-tol),S<437*(1+tol)) %>% arrange(S)

# Simulations
#       m     a        S        L         C    alpha
# 4 0.022 0.021 385.7151 2143.468 0.0144348  1.047619
# 7 0.044 0.041 381.4585 2150.424 0.01477366 1.073171
# 10 0.084 0.076 380.7409 2146.395 0.01480693 1.105263

AA <- metaWebNetAssembly(A,0.023,1,0.094,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))

# Running averages
plot_NetAssemblyModel_eqw(AA,100,"Figures/PotterCoveMeta-webSim_avg.png")

# Time series plot
plot_NetAssemblyModel(AA,300,"Figures/PotterCoveMeta-webSim_ts.png")

AA <- metaWebNetAssembly(A,0.084,1,0.076,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))

plot_NetAssemblyModel_eqw(AA,100,"Figures/Weddell_Meta-webSim_avg.png")
plot_NetAssemblyModel(AA,300,"Figures/Weddell_Meta-webSim_ts.png")

rm(sim)
save.image()

# Plot of five simulations 
#
gg <- plot_NetAssemblyModel(AA,100)

# Plot of S and C for Weddell 
#
require(cowplot)
AA <- metaWebNetAssembly(A,0.084,1,0.076,tf)
g3 <- plot_grid(gg[[1]],gg[[3]],labels = c("A","B"),align = "h")
save_plot("Figures/Weddell_Meta-webSim_SC.png",g3,base_width=8,base_height=5,dpi=300)


```



# Local web (Potter Cove) compared to  metaWeb assembly model 

```{r PotterGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}


#sourceCpp("src/NetAssemblyFromMetaWeb.cpp")

#
# Read data and trim species names to avoid duplicates 
#
dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))

#
# Select meta web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
# Delete cannibalistic 
redl <- simplify(redl)
sum(degree(redl,mode="in")==0)

A <- get.adjacency(redl,sparse=F)
dim(A)                             

#
# Select Local food web 
# 

dtot1 <- as.matrix(dtot %>% filter(Network=="Local") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)

#
# Calculate Trophic Position
#
require(NetIndices)
TL <-TrophInd(get.adjacency(redl,sparse=F),Dead=c("Fresh detritus","Aged detritus","Necromass"))

#
# Compare modularity 
#
require(tictoc)
m <- 0.023
a <- 0.094
tic()
tblMdlWeb <- calc_modularity_metaWebAssembly(redl, A, m,a,1000,TL)
toc()

tblMdlWeb <- tblMdlWeb %>% mutate(Network="Local") %>% inner_join(dplyr::select(websTbl,Size:Modularity), by="Network")

#
# Calculate z-score of modularity
#
tblMdlWeb <- tblMdlWeb %>% mutate(zMO= (Modularity- mdlMO)/(MOhigh-MOlow)*2, zGR=(Groups-mdlGR)/(GRhigh-GRlow)*2)

websAssemblyModel <- dplyr::select(tblMdlWeb,Network:Modularity,mdlCC:zTI,zMO:zGR)
#websAssemblyModel <- bind_rows(websAssemblyModel, dplyr::select(tblMdlWeb,Network:Modularity,mdlCC:zTI,zMO:zGR))

save.image()

```



# Regional web (Weddell) compared to  metaWeb assembly model 

```{r WeddellGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Select "Regional" food web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Regional") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
redl <- simplify(redl)


require(NetIndices)
TL<-TrophInd(get.adjacency(redl,sparse=F),Dead=c("Detritus","Necromass"))

#
# Compare modularity 
#
require(tictoc)
m <- 0.084 
a <- 0.076
tic()
tblMdlWeb <- calc_modularity_metaWebAssembly(redl, A, m,a,1000,TL)
toc()

tblMdlWeb <- tblMdlWeb %>% mutate(Network="Regional") %>% inner_join(dplyr::select(websTbl,Size:Modularity), by="Network")

#
# Calculate z-score of modularity
#
tblMdlWeb <- tblMdlWeb %>% mutate(zMO= (Modularity- mdlMO)/(MOhigh-MOlow)*2, zGR=(Groups-mdlGR)/(GRhigh-GRlow)*2)

websAssemblyModel <- bind_rows(websAssemblyModel, dplyr::select(tblMdlWeb,Network:Modularity,mdlCC:zTI,zMO:zGR))

save.image()

```


# Motif Potter Cove compared to  metaWeb assembly model 

```{r PotterMotifMetaWebAssembly, eval=F,echo=F,message=T,warning=T}


#sourceCpp("src/NetAssemblyFromMetaWeb.cpp")

#
# Read data and trim species names to avoid duplicates 
#
dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))

#
# Select meta web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
# Delete cannibalistic 
redl <- simplify(redl)
sum(degree(redl,mode="in")==0)

A <- get.adjacency(redl,sparse=F)
dim(A)                             

#
# Select Local food web 
# 

dtot1 <- as.matrix(dtot %>% filter(Network=="Local") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)

#
# Motif
#
mot <- triad_census(redl)

mot[4] # Exploitative competition
mot[5] # Apparent competition
mot[6] # Tri-trophic chain
mot[9] # Omnivory

#FreqMotif <- data.frame(Network="Local",t(mot))

set.seed(123)
m <- 0.023
a <- 0.094
motif_metaWeb <- calc_motif_metaWebAssembly(redl, A, m,a,1000)

motif_metaWeb <- motif_metaWeb %>% mutate(Network="Local")


save.image()

```


# Motif Weddell compared to  metaWeb assembly model 

```{r WeddellMotifMetaWebAssembly, eval=T,echo=F,message=T,warning=T}


#
# Select "Regional" food web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Regional") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
redl <- simplify(redl)


#
# Motif
#
set.seed(123)

m <- 0.084 
a <- 0.076
m_metaWeb <- calc_motif_metaWebAssembly(redl, A, m,a,1000)

motif_metaWeb <- bind_rows(motif_metaWeb, m_metaWeb %>% mutate(Network="Regional"))

rm(m_metaWeb)
save.image()


select(motif_metaWeb, explComp,EClow,EChigh)
select(motif_metaWeb, apprComp,AClow,AChigh,zAC)
select(motif_metaWeb, triTroph,TTlow,TThigh,zTT)
select(motif_metaWeb, omnivory,OMlow,OMhigh,zOM)

# Generate tables for the manuscript
#
#
require(pander)
panderOptions('table.split.table',Inf)
panderOptions('table.style', 'multiline')

webs_tmp <- inner_join(websAssemblyModel,dplyr::select(websTbl,Q,mTI,Network), by="Network")

pandoc.table(t(webs_tmp %>% dplyr::select(Network,SWness,SWnessCI,zQ,zTI,zMO,zGR,mTI) %>% mutate_if(is.numeric, round, digits=4)))


pandoc.table(t(webs_tmp %>% dplyr::select(Network,Q,Qlow,Qhigh,mTI,TIlow,TIhigh,Modularity, MOlow,MOhigh) %>% mutate_if(is.numeric, round, digits=4)))

pandoc.table(t(motif_metaWeb %>% rename(EC=explComp,AC=apprComp,TT=triTroph,OM=omnivory) %>%
                 dplyr::select(Network,EC,EClow,EChigh,zEC,AC,AClow,AChigh,zAC,TT,TTlow,TThigh,zTT,OM,OMlow,OMhigh,zOM) %>% mutate_if(is.numeric, round, digits=2)))


# Plot of random z-score motif normalized
#
#

require(tidyr)
names(motif)
pFM1 <- motif %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,value,zEC:zOM) %>% mutate(type="Random z-score")
pFM1$Network <- factor(pFM1$Network)
levels(pFM1$Network) <- c("Potter Cove","Meta-web","Weddell Sea")

# Normalize z-scores
#
pFM1 <- pFM1 %>% group_by(Network) %>% mutate(normZ=value/sum(sqrt(value^2)))

g1 <- ggplot(pFM1,aes(x=Network,y=normZ,fill=motif)) + geom_bar(stat="identity",position=position_dodge()) +
   scale_fill_brewer(palette = "RdYlGn",breaks=c("zEC","zAC","zTT","zOM"),name="Motif\nZ-score",   labels=c("Exploitative\ncompetition", "Apparent\ncompetition", "Tri-trophic\nchain","Omnivory")) + guides(fill=FALSE) +
   xlab("") + ylab("") + theme_bw() + scale_x_discrete(limits=c("Potter Cove","Weddell Sea","Meta-web")) + expand_limits(y=c(0.75,-0.35)) #+ theme(legend.position="bottom")
g1

# Plot of assembly motifs normalized 
#
names(motif_metaWeb)
pFM2 <- motif_metaWeb %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,value,zEC:zOM) %>% mutate(type="Assembly z-score", Network=factor(Network))

levels(pFM2$Network) <- c("Potter Cove","Weddell Sea")

pFM2 <- pFM2 %>% group_by(Network) %>% mutate(normZ=value/sum(sqrt(value^2)))

g2 <- ggplot(pFM2,aes(x=Network,y=normZ,fill=motif)) + geom_bar(stat="identity",position=position_dodge()) +
   scale_fill_brewer(palette = "RdYlGn",breaks=c("zEC","zAC","zTT","zOM"),name="Motif\nZ-score",   labels=c("Exploitative\ncompetition", "Apparent\ncompetition", "Tri-trophic\nchain","Omnivory")) +
   xlab("") + ylab("") + theme_bw() + scale_x_discrete(limits=c("Potter Cove","Weddell Sea","Meta-web")) + expand_limits(y=c(0.75,-0.35)) #+ theme(legend.position="bottom")

g2
require(cowplot)
g3 <- plot_grid(g1,g2,labels = c("A","B"),align = "h",rel_widths=c(.9,1.2))
g3
save_plot("Figures/Motif_Zs_ByNetwork.png",g3,base_width=8,base_height=5,dpi=600)



```

# Topologcal roles with meta-web assembly model 

```{r MetaWebTopologicalRoles, eval=T,echo=F,message=T,warning=T}

# Check the correct meta-web adjacency matrix is loaded

dim(A)==c(859,859)

#
# 500 time steps 
#
tf <- 500
set.seed(1234)

# Weddell Sea 
#
#
m <- 0.084 
a <- 0.076
tf <- 531
AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
dfA$S[tf-200]
plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

g <- graph_from_adjacency_matrix( AA$A, mode  = "directed")
# Select only a connected subgraph graph 
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
vcount(g)
modulos<-cluster_spinglass(g)

topoRoles_metaWebAssembly <- calc_avg_topological_roles(g,"Weddell",10)   # 30 simulations are enough to obtain stable topological roles

# Initialize hub_conn
hub_conn_Assembly <- data.frame()

# Plot and clasify topological roles
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(topoRoles_metaWebAssembly,g,modulos) %>% mutate(Network="Weddell"))

plotTopoRolesByTLByMod("","Weddell","",modulos,hub_conn_Assembly,"",g)


# Potter Cove Simulations
#
#

set.seed(123)
m <- 0.023
a <- 0.094
tf <- 546
#require(Rcpp)
#sourceCpp("src/NetAssemblyFromMetaWeb.cpp")

AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))

plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

AA$S[tf]

g <- graph_from_adjacency_matrix( AA$A*1, mode  = "directed")
# Add Names
#V(g)$label <- rownames(A)

# Select only a connected subgraph graph 
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
#plot(g,edge.arrow.size=.4,edge.color="orange", vertex.color="gray50",vertex.size=3,layout=layout_with_fr)
vcount(g)
sum(degree(g,mode="in")==0)
V(g)[degree(g,mode="in")==0]$label

modulos<-cluster_spinglass(g)

tR <- calc_avg_topological_roles(g,"Potter",10)
topoRoles_metaWebAssembly <- bind_rows(topoRoles_metaWebAssembly,tR )


# Plot and clasify topological roles
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(tR,g,modulos) %>% mutate(Network="Potter"))

plotTopoRolesByTLByMod("","Potter","",modulos,hub_conn_Assembly,"",g)

save.image()
# Topological Roles proportions test and plot
#
#
names(hub_conn)


tbl <- table(hub_conn$Network,hub_conn$type)

tbl1 <- table(hub_conn_Assembly$Network,hub_conn_Assembly$type)
tbl1 <- rbind(tbl,tbl1) 
tbl1 <- tbl1[c(2,4,5),]
class(tbl1) <- "table"

chisq.test(tbl1,simulate.p.value = TRUE, B=10000)

require(ggplot2)
require(scales)
df1 <- data.frame(tbl1) 
names(df1) <- c("Network","Rol","count")
df1 <- filter(df1,count!=0)
df1 <- df1 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df1$Network <- factor(df1$Network, levels=c("Potter","Weddell","Meta")) 

levels(df1$Network) <- c("Potter Cove\nModel","Weddell Sea\nModel","Meta-web")


gP1 <- ggplot(df1,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity") + 
  scale_fill_brewer(palette = "RdYlGn",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")


# Proportion of topo roles of the real networks
#
df2 <- data.frame(tbl,stringsAsFactors = FALSE)
names(df2) <- c("Network","Rol","count")
df2 <- filter(df2,count!=0)
df2 <- df2 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df2$Network <- factor(df2$Network, levels=c("Local","Regional","Meta")) 
levels(df2$Network) <- c("Potter Cove","Weddell Sea","Meta-web")

gP2 <- ggplot(df2,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity") + 
  scale_fill_brewer(palette = "RdYlGn",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")

legend_b <- get_legend(gP2 + theme(legend.position="bottom"))

require(cowplot)
gP3 <- plot_grid(gP2,gP1,labels = c("A","B"),align = "h")
gP3 <- plot_grid( gP3, legend_b, ncol = 1, rel_heights = c(1, .05))
save_plot("Figures/PropRoles_ByNetwork_Model.png",gP3,base_width=8,base_height=5,dpi=600)
#ggsave("Figures/PropMotif_Roles_ByNetwork.png",width=8,height=5,units="in",dpi=600)

save.image()
```

