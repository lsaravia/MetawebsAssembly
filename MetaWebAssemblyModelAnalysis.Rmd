---
title: "From metawebs to regional and local"
author: "L.A.S."
output: html_document
editor_options: 
  chunk_output_type: console
---

## Setup

- I run the analysis setting `eval=True` or `eval=False` to run a particular chunk, not the whole Rmd. 

- To run the simulations for each metaweb fit, I first read the dataset, turning on the corresponding chhunk, then I run the fitting procedure turning on that chunk.  

```{r setup, echo=FALSE }
if(file.exists(".RData")) load(".RData")

needed_packages <- c(
    "ggplot2"
  , "igraph"
  , "dplyr"
  , "stringr"
  , "devtools")

lapply(needed_packages, function(x) { if(!require(x,character.only = TRUE)){ install.packages(x) }} )

theme_set(theme_bw())

if( require(meweasmo) == FALSE)
  install_github("lsaravia/meweasmo")
if( require(multiweb) == FALSE)
  install_github("lsaravia/multiweb")

source("R/network_fun.r")

```

# Read Antarctic Networks

```{r readAntarctic, eval=FALSE,echo=F,message=T,warning=T}
#
# Read the Antarctic Metawebs files with New Weddell from @Brose2019 (GATEWAy database)
#
dn <- list.files("Data",pattern = "^[MWP].*\\.dat$")
dn <- paste0("Data/", dn)
dn <- dn[c(2,3,1)]
ig_list <- readNetwork(dn,edgeListFormat=2)
names(ig_list) <- c("Ant_Potter","Ant_Weddell","Ant_Meta")

redl <- ig_list[["Ant_Meta"]]
sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network=="Ant_Meta") %>% dplyr::select(Basal)

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]
#
# Add Meta web variable to use in simulations
#
Ant_Meta <- redl
```


## Read the Islands data set 

```{r readIslands, eval=FALSE,echo=TRUE,message=FALSE }

#
# Extract Weddell Sea from GATEWAy database
#
ga <- readr::read_csv("~/Dropbox/Projects/MetaWebsAssembly/Data/283_2_FoodWebDataBase_2018_12_10.csv",col_types = "icccccccccccccddddddccccccccddddddcddccddciicc")

fw_name <- ga %>% filter(grepl("Piechnik",link.citation )) %>% distinct(foodweb.name)                
Have_df <- ga %>% filter(grepl("Piechnik",link.citation )) %>% dplyr::select(con.taxonomy,con.taxonomy.level,res.taxonomy,res.taxonomy,foodweb.name)
require(igraph)
dtot1 <- as.matrix(Have_df %>% dplyr::select(res.taxonomy,con.taxonomy))
have1  <- graph_from_edgelist(dtot1, directed  = T)

df_list <- Have_df %>% group_split(foodweb.name)
ig_list <- lapply(df_list, function(fw) {
  d1 <- as.matrix(fw %>% dplyr::select(res.taxonomy,con.taxonomy))
  graph_from_edgelist(d1, directed  = T)
})
names(ig_list) <- paste0("Isl_",fw_name$foodweb.name)
ig_list <- c(ig_list, list(Isl_Meta=have1))

redl <- ig_list[["Isl_Meta"]] 

stopifnot(sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network=="Isl_Meta") %>% dplyr::select(Basal))

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]
#
# Add Meta web variable to use in simulations
#
Isl_Meta <- redl


```

# Read the Lakes dataset 

```{r readLakes, eval=FALSE,echo=TRUE,message=FALSE }

require(tidyverse)

#
# Extract Weddell Sea from GATEWAy database
#
ga <- readr::read_csv("~/Dropbox/Projects/MetaWebsAssembly/Data/283_2_FoodWebDataBase_2018_12_10.csv",col_types = "icccccccccccccddddddccccccccddddddcddccddciicc")

fw_name <- ga %>% filter(grepl("Havens",link.citation )) %>% distinct(foodweb.name)                
Have_df <- ga %>% filter(grepl("Havens",link.citation )) %>% dplyr::select(con.taxonomy,con.taxonomy.level,res.taxonomy,res.taxonomy,foodweb.name)
require(igraph)
dtot1 <- as.matrix(Have_df %>% dplyr::select(res.taxonomy,con.taxonomy))
have1  <- graph_from_edgelist(dtot1, directed  = T)

df_list <- Have_df %>% group_split(foodweb.name)
ig_list <- lapply(df_list, function(fw) {
  d1 <- as.matrix(fw %>% dplyr::select(res.taxonomy,con.taxonomy))
  graph_from_edgelist(d1, directed  = T)
})

names(ig_list) <- paste0("Lak_",str_replace_all(fw_name$foodweb.name," ","_"))
ig_list <- c(ig_list, list(Lak_Meta=have1))

redl <- ig_list[["Lak_Meta"]] 

stopifnot(sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network=="Lak_Meta") %>% dplyr::select(Basal))

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]
#
# Add Meta web variable to use in simulations
#
Lak_Meta <- redl

```

# Check the steady state of the model    

```{r checkSteadyState, eval=F,echo=F,message=T,warning=T}


set.seed(2312)
#
# Testing if 500 time steps is enough to find equilibrium point
#
#
# Testing for the CT model
#
tf <- 3000
m <- rep(0.1,times=dimA)
e <- rep(0.3, times=dimA)
se <- rep(0.3, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP <- plot_NetAssemblyModel_eqw(AA,50)
AAdf <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 1500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
AAdf1 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 1000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP1 <- plot_NetAssemblyModel_eqw(AA,50)
AAdf2 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf3 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
AAdf4 <- tibble(C=AA$L[2:100]/ (AA$S[2:100])^2 ,S=AA$S[2:100]) %>% mutate(mC = mean(C), mS=mean(S)) 

require(ks)
kde.test(AAdf3[,1:2],AAdf[,1:2])$pvalue
# [1] 0.2421669
kde.test(AAdf3[,1:2],AAdf1[,1:2])$pvalue
# [1] 0.5166524
kde.test(AAdf3[,1:2],AAdf2[,1:2])$pvalue
# [1] 0.2582594
##
# Testing the first 100 time steps against the last 100 of the '500' simulation
kde.test(AAdf4[,1:2],AAdf3[,1:2])$pvalue
# [1] 0.05814453

AAdfTot <- bind_rows(AAdfTot, 
                     bind_rows(AAdf %>% mutate(Sim="2000"), AAdf1 %>% mutate(Sim="1500"), AAdf2 %>% mutate(Sim="1000"), AAdf3 %>% mutate(Sim="500")) %>% mutate(model_type="Continuous")
                     )
ggplot(AAdfTot, aes(S,C,color=Sim))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)

#
# Changing parameters
#
#
# Testing if 500 time steps is enough to find equilibrium point
#
set.seed(2312)

t_window <-  100
tf <- 3000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP2 <- plot_NetAssemblyModel_eqw(AA,50)
AAdf <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 


tf <- 1500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf1 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 

tf <- 1000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP3 <- plot_NetAssemblyModel_eqw(AA,50)

AAdf2 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 


tf <- 5000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf4 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 

tf <- 500
t_window <- 100
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf3 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 


#
# Kernel density based global two-sample comparison test 2d 
# to determine if the last 100 time steps have the same distribution of C and S 
# and therefore there is steady state
#
require(ks)
kde.test(AAdf3[,1:2],AAdf[,1:2])$pvalue
# [1] 0.5316762
kde.test(AAdf3[,1:2],AAdf1[,1:2])$pvalue
# 0.3481172
kde.test(AAdf3[,1:2],AAdf2[,1:2])$pvalue
# [1] 0.1103454
#
# There are differences p<0.05 due to the ciclic dynamics

AAdf <- bind_rows(AAdf , AAdf1, AAdf2, AAdf3,AAdf4) %>% mutate(model_type="Continuous",e=0.005)
AAdfTot <- bind_rows(AAdfTot,AAdf)
ggplot(AAdf , aes(S,C,color=factor(Sim)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)

#  + theme(axis.text.x=element_blank(),axis.title.x=element_blank())
gP5 <- plot_grid(gP$g1,
                 gP$g2,
                 gP1$g1 ,
                 gP1$g2 ,
                 align = "hv",
                  ncol = 2)
save_plot("Figures/Metaweb_steady_state_Potter.png",gP5,base_width=6,base_height=6,dpi=600)

gP5 <- plot_grid(gP2$g1 ,
                 gP2$g2 ,
                 gP3$g1 ,
                 gP3$g2 ,
                 align = "hv",
                  ncol = 2)

save_plot("Figures/Metaweb_steady_state_Weddell.png",gP5,base_width=6,base_height=6,dpi=600)


#ggsave("Figures/Metaweb_SteadyState_byModel.png",width=8,height=5,units="in",dpi=600)

```

* The discrete time and continuous time models give the same results, this is a verification that the models are well implemented and that the timmings of events have no influence on the results. So we use the continuous model (randomized order of events).  


# Checking differences with m and a parameters, to know if we can use lambda=m/a as a unique parameter

```{r checklambda, eval=F,echo=F,message=T,warning=T}



#
# Testing if there are difference with different m/e 
#      m      a     S     L      C    se model     model_type alpha distance min_dist
# 0.0263 0.106   92.1  324. 0.0383 0.691 Prob      Continuous 0.247  0.00339 TRUE    
# 0.0145 0.0522  91.4  322. 0.0385 0.254 Prob      NA         0.278  0.00786 TRUE    

AAdf <- tibble()
set.seed(2312)

tf <- 1000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=0.25,model_type="Discrete") )


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),se=0.25,e=0.05,model_type="Discrete") )

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)


# 
# Continous time 0.0263 0.106   92.1  324. 0.0383 0.691
#
tf <- 1000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),se=0.25,e=0.005,model_type="Continuous"))


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),se=0.25,e=0.05,model_type="Continuous"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~model_type)


#
# se = 1 
#
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=1,model_type="Discrete")) 


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=1,model_type="Discrete"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( se ~ model_type)


# 
# Continous time 0.0263 0.106   92.1  324. 0.0383 0.691
#
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=1,model_type="Continuous"))


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=1,model_type="Continuous"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) +
  facet_grid( se ~ model_type)

#
# se = 0 
#
tf <- 1000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=0,model_type="Discrete")) 


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=0,model_type="Discrete"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( se ~ model_type)


# 
# Continous time 0.0263 0.106   92.1  324. 0.0383 0.691
#
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=0,model_type="Continuous"))


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=0,model_type="Continuous"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) +
  facet_grid( se ~ model_type)


ggsave("Figures/Metaweb_SecExtc_byModel.png",width=8,height=5,units="in",dpi=600)

```

* there are differences when secondary extinctions are >0 and mainly in the temporal SD so we keep using the 2 parameters


# Antarctic Metaweb Simulate a grid of parameters to select the best options


```{r makeSimulations150000tf1000, eval=FALSE,echo=F,message=T,warning=T}

simMetaWebAssembly <- tibble()

# simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")
# simMetaWebAssembly <- simMetaWebAssembly %>% filter(Metaweb!="Ant") 
# simMetaWebAssembly %>% count(Metaweb,model_type,model)


#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
#
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)

# simulations with probability of secondary extinction == 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2, 150000, par_ranges,A, 1 ) %>% mutate(model_type="Continuous",Metaweb="Ant")

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction != 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A, 1) %>% mutate(model_type="Continuous",Metaweb="Ant")

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")


# simulations with probability of secondary extinction == 0
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  150000, par_ranges,A,1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# Set the type of models according to probability of secondary extinction
#
# simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ))
knitr::kable(simMetaWebAssembly %>% group_by(model,model_type) %>% summarise(n=n()))

p1 <- ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Connectance,color=Network),size=0.5) + 
  coord_cartesian(ylim=c(0.01,0.1)) +  
  facet_wrap(~ model) + scale_color_brewer(palette= "Paired", guide=FALSE)

ggplot(simMetaWebAssembly, aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl, aes(Size,Links,color=Network),size=0.3) + coord_cartesian(ylim=c(0,3000)) + facet_wrap(~model)

# ggplot(simMetaWebAssembly %>% filter(model=="Prob"), aes(S,C,color=model_type))+ geom_point(size=.1,alpha=0.5) + theme_bw() + coord_cartesian(ylim=c(0,0.1)) + scale_color_brewer(palette= "Dark2",name="")#, labels=c("Fixed Sec.Ext.", "Potter","Meta", "No Sec.Ext.", "Prob. Sec.Ext.","Weddell" ))  
# ggsave("Figures/Metaweb_Continuous_Discrete.pdf",width=8,height=5,units="in",dpi=600)


ggplot(simMetaWebAssembly %>% filter(model=="Prob"), aes(S,C,color=model_type))+ geom_point(size=.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Connectance,color=Network),size=0.4) + coord_cartesian(ylim=c(0,0.1)) + scale_color_brewer(palette= "Dark2",name="")#, labels=c("Fixed Sec.Ext.", "Potter","Meta", "No Sec.Ext.", "Prob. Sec.Ext.","Weddell" ))  
rm(sim,par_ranges,AAdf,AAdf1,AAdf2,AAdf3,AAdf4,AAdfTot,f)
save.image()
```


## Make the fit finding the parameters with less distance to empirical networks

```{r fitMetaWebPC50002, eval=FALSE,echo=F,message=T,warning=T}


#
# Potter Cove
#
# Use this tolerance = tol to display a more detailed plot 
fittedMetaWeb <- bind_rows(fittedMetaWeb, fit_metaWebAssembly_model(websTbl, "Ant_Potter", simMetaWebAssembly))
fittedMetaWeb <- bind_rows(fittedMetaWeb, fit_metaWebAssembly_model(websTbl, "Ant_Weddell", simMetaWebAssembly))

## Perform ABC and GOF
#
# fittedMetaWeb_gof <- tibble()
# netnames <- names(ig_list)
# netnames <- netnames[ netnames != "Ant_Meta" ] 
# 
# fmw <-  lapply(netnames, function(n){
# 
#   CI_metaWebAssembly_model(websTbl, n, simMetaWebAssembly,plot=FALSE)
# })
# fittedMetaWeb_gof <- bind_rows(fittedMetaWeb_gof,fmw)

knitr::kable(fittedMetaWeb %>% dplyr::select( Network,  everything(), -min_dist) %>% arrange(Network))

rm(X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ravg,sel,redl,ig_list,web,fmw)
save.image()

```


* Fit of Metaweb model by variant usin C and S

|Network     |         m|         a|        se|         S|         L|         C|model_type |Metaweb |model     |     alpha|  distance|fit_type |
|:-----------|---------:|---------:|---------:|---------:|---------:|---------:|:----------|:-------|:---------|---------:|---------:|:--------|
|Ant_Potter  | 0.0185036| 0.1269833| 0.0000000|  92.35644|  325.1782| 0.0381230|Continuous |Ant     |No SecExt | 0.1457165| 0.0081407|S-C      |
|Ant_Potter  | 0.0409665| 0.2375224| 0.2219146|  94.87129|  367.0495| 0.0407807|Continuous |Ant     |Prob      | 0.1724744| 0.0694620|S-C      |
|Ant_Potter  | 0.0144288| 0.0864320| 1.0000000|  87.28713|  331.4554| 0.0435036|Continuous |Ant     |Fixed     | 0.1669378| 0.1424930|S-C      |
|Ant_Weddell | 0.0207792| 0.0131341| 0.4088838| 446.70297| 7646.4554| 0.0383197|Continuous |Ant     |Prob      | 1.5820785| 0.4354927|S-C      |
|Ant_Weddell | 0.0139139| 0.0096195| 1.0000000| 441.68317| 7272.8218| 0.0372805|Continuous |Ant     |Fixed     | 1.4464271| 0.4528557|S-C      |
|Ant_Weddell | 0.0298641| 0.0259663| 0.0000000| 444.68317| 6772.1485| 0.0342472|Continuous |Ant     |No SecExt | 1.1501116| 0.4960883|S-C      |



# Islands Metaweb Simulate a grid of parameters to select the best options


```{r IslandSimulations150000tf1000, eval=FALSE,echo=F,message=T,warning=T}

metaweb_name <-  "Isl_Meta"

# Check redl is the metaweb
# 
stopifnot(  sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network==metaweb_name) %>% select(Basal) )

metaweb_name <- str_sub(metaweb_name,1,3)

A <- get.adjacency(redl,sparse=F)
dimA <- nrow(A)

# Simulate a grid of parameters to select the best options using latin hypercubic sampling
#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
#
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)

# simulations with probability of secondary extinction == 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2, 150000, par_ranges,A, 1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction != 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A, 1) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")


# simulations with probability of secondary extinction == 0
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  150000, par_ranges,A,1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# Set the type of models according to probability of secondary extinction
#
#simMetaWebAssembly <- bind_rows(simMetaWebAssembly, readRDS("Data/simulations_metaWebAssembly.rds"))
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ))
knitr::kable(simMetaWebAssembly %>% group_by(Metaweb,model,model_type) %>% summarise(n=n()))

p2 <- ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Connectance,color=Network),size=0.5) + 
  coord_cartesian(ylim=c(0.05,.5)) + 
  facet_wrap(~ model) + scale_color_brewer(palette= "Paired",guide=FALSE)

ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Links,color=Network),size=0.3) + 
  coord_cartesian(ylim=c(0,3000)) + 
  facet_wrap(~model)  + scale_color_brewer(palette= "Dark2")

# ggsave("Figures/Metaweb_Continuous_Discrete.pdf",width=8,height=5,units="in",dpi=600)
```

## Make the fit Islands

```{r fitMetaWebIslands, eval=FALSE,echo=F,message=T,warning=T}
#
#
# Use this tolerance = tol to display a more detailed plot 

netnames <- names(ig_list)
netnames <- netnames[ netnames != "Isl_Meta" ] 
fmw <-  lapply(netnames, function(n){

  fit_metaWebAssembly_model(websTbl, n, simMetaWebAssembly)
})

fittedMetaWeb <- bind_rows(fittedMetaWeb, fmw)

## Perform ABC and GOF
#
# fmw <-  lapply(netnames, function(n){
# 
#   CI_metaWebAssembly_model(websTbl, n, simMetaWebAssembly)
# })
# fittedMetaWeb_gof <- bind_rows(fittedMetaWeb_gof,fmw)

knitr::kable(fittedMetaWeb %>% dplyr::select( Metaweb,Network,  everything(), -min_dist, -model_type,-fit_type) %>% arrange(Network), digits = 4)

rm(netnames,fmw,X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ravg,sel,redl,ig_list,web)
save.image()

```


# Lakes Metaweb Simulate a grid of parameters to select the best options


```{r LakesSimulations150000tf1000, eval=FALSE,echo=F,message=T,warning=T}

metaweb_name <-  "Lak_Meta"

# Check redl is the metaweb
# 
stopifnot(  sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network==metaweb_name) %>% select(Basal) )

metaweb_name <- str_sub(metaweb_name,1,3)

A <- get.adjacency(redl,sparse=F)
dimA <- nrow(A)

# Simulate a grid of parameters to select the best options using latin hypercubic sampling
#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
#
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)

# simulations with probability of secondary extinction == 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2, 150000, par_ranges,A, 1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction != 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A, 1) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")


# simulations with probability of secondary extinction == 0
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  150000, par_ranges,A,1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# Set the type of models according to probability of secondary extinction
#
#simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ))
knitr::kable(simMetaWebAssembly %>% group_by(Metaweb,model,model_type) %>% summarise(n=n()))

# Save the updated dataset with all simulations and models: 3 metawebs, 3 models, 150000*9=1350000 records  
#
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

(p2 <- ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Connectance,color=Network),size=0.5) + 
  coord_cartesian(ylim=c(0.05,.5)) + 
  facet_wrap(~ model) + scale_color_brewer(palette= "Paired",guide=FALSE))

ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Links,color=Network),size=0.3) + 
  coord_cartesian(ylim=c(0,3000)) + 
  facet_wrap(~model)  + scale_color_brewer(palette= "Dark2")

# ggsave("Figures/Metaweb_Continuous_Discrete.pdf",width=8,height=5,units="in",dpi=600)

rm(p1,p2,ga,have1,Have_df,dtot1,df_list,redl,simMetaWebAssembly)
save.image()
```

## Make the fit Lakes

```{r fitMetaWebLakes, eval=FALSE,echo=F,message=T,warning=T}
#
#
# Use this tolerance = tol to display a more detailed plot 

netnames <- names(ig_list)
netnames <- netnames[ netnames != "Lak_Meta" ] 
fmw <-  lapply(netnames, function(n){

  fit_metaWebAssembly_model(websTbl, n, simMetaWebAssembly)
  
})

fittedMetaWeb <- bind_rows(fittedMetaWeb, fmw)

## Perform ABC and GOF
#
# fmw <-  lapply(netnames, function(n){
# 
#   CI_metaWebAssembly_model(websTbl, n, simMetaWebAssembly)
# })
# fittedMetaWeb_gof <- bind_rows(fittedMetaWeb_gof,fmw)
# fittedMetaWeb_gof <- fittedMetaWeb_gof %>% mutate(Metaweb = str_sub(Network,1,3)) %>% dplyr::select( Metaweb,Network,  everything())
# #  
# fittedMetaWeb_gof %>% mutate(fit=gof_pvalue>0.1) %>% group_by(model,fit) %>% summarise(n=n()) %>% mutate(freq=n/sum(n))
# knitr::kable(fittedMetaWeb_gof %>% ungroup() %>%  dplyr::select(-model_type,-fit_type) %>% arrange(Network), digits = 4)


knitr::kable(fittedMetaWeb %>% ungroup() %>% dplyr::select( Metaweb,Network,  everything() )%>% dplyr::select(-min_dist, -model_type,-fit_type) %>% arrange(Network), digits = 4)

rm(netnames,fmw,X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ga,ravg,sel,redl,ig_list,web,have1,Have_df)
save.image()

```

# Make simulations with fitted parameters with S-C method

* As connectivity is determines most of other network properties we fit by connectivity and number of species

|model     |  n|      freq|
|:---------|--:|---------:|
|Fixed     | 14| 0.2456140|
|No SecExt | 18| 0.3157895|
|Prob      | 25| 0.4385965|

```{r fitMetaWebSims, eval=FALSE,echo=F,message=T,warning=T}

knitr::kable( fittedMetaWeb %>% group_by(Metaweb,Network) %>% top_n(-1,distance) %>% ungroup() %>% group_by(model) %>% summarise(n=n()) %>% mutate(freq = n / sum(n)))

# Ant_Meta
# Lak_Meta
# Isl_Meta


#
# Potter - No SecExt (best fit)
#
simulate_plot_metaweb_assembly(Ant_Meta,fittedMetaWeb,websTbl,"Ant_Potter")

#
# Weddell - Prob
#
simulate_plot_metaweb_assembly(Ant_Meta,fittedMetaWeb,websTbl,"Ant_Weddell")

#
# Isl_FloridaIslandE3 - Prob
#
simulate_plot_metaweb_assembly(Isl_Meta,fittedMetaWeb,websTbl,"Isl_FloridaIslandE3")

#
# Isl_FloridaIslandE9 - Fixed
#
simulate_plot_metaweb_assembly(Isl_Meta,fittedMetaWeb,websTbl,"Isl_FloridaIslandE9")

#
# Lak_Hoel_lake - Fixed
#
simulate_plot_metaweb_assembly(Lak_Meta,fittedMetaWeb,websTbl,"Lak_Hoel_lake")


#
# Lak_Federation_lake - Fixed
#
simulate_plot_metaweb_assembly(Lak_Meta,fittedMetaWeb,websTbl,"Lak_Federation_lake")

```



# Local web (Potter Cove) compared to  metaWeb assembly model (TEST)


```{r PotterGlobalMetaWebAssembly, eval=FALSE,echo=F,message=T,warning=T}

A <- get.adjacency(Ant_Meta,sparse=F)
      

#
# Select Local food web 
# 
net_name <- pull( websTbl %>% filter(!ismeta) %>% dplyr::select(Network) )
f <- fittedMetaWeb %>% filter(Network == net_name[1])
tictoc::tic()
tbl <- calc_modularity_metaWebAssembly(websTbl, net_name[1], A, f$m[1], f$a[1], f$se[1],1000)
tictoc::toc()
sim <- tbl$sim

tblMdlWeb <- tbl$su %>% mutate(Network=net_name[1],model=f$model[1]) %>% inner_join(dplyr::select(websTbl,Network:Modularity)) %>%
  dplyr::select(Network:Modularity,mdlCC:zMEing)

#
# Correct the calculation of z-score
#
if(!exists("websAssemblyModel")) websAssemblyModel <- tibble()
websAssemblyModel <- websAssemblyModel %>% bind_rows(tblMdlWeb) 
if( !exists("websAssemblyModelSim")) websAssemblyModelSim <- tibble()
websAssemblyModelSim <-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network=net_name[1],model=f$model[1]))  
rm(sim,tblMdlWeb,tbl,f)
save.image()



```



# Antarctic Metaweb assembly model 

```{r AntarcticMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModel")) websAssemblyModel <- tibble()
if(!exists("websAssemblyModelSim")) websAssemblyModelSim <- tibble()

A <- get.adjacency(Ant_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Ant") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_modularity_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)
    tictoc::tic("calc_modularity_metaWebAssembly")
    tbl <- calc_modularity_metaWebAssembly(websTbl, fw, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()
    sim <- tbl$sim
    
    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network:Modularity)) %>%
                            dplyr::select(Network:Modularity,mdlCC:zMO)

    websAssemblyModel <<- websAssemblyModel %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSim <<-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()

```

# Islands Metaweb assembly model 

```{r IslMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModel")) websAssemblyModel <- tibble()
if(!exists("websAssemblyModelSim")) websAssemblyModelSim <- tibble()

A <- get.adjacency(Isl_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Isl") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){

    message(paste("\ncalc_modularity_metaWebAssembly", fw, model_name))

    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)
    tbl <- calc_modularity_metaWebAssembly(websTbl, fw, A, f$m[1], f$a[1], f$se[1],10)
    sim <- tbl$sim

    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network:Modularity)) %>%
                            dplyr::select(Network:Modularity,mdlCC:zMO)

    websAssemblyModel <<- websAssemblyModel %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSim <<-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()

```


# Lakes Metaweb assembly model 

```{r LakMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModel")) websAssemblyModel <- tibble()
if(!exists("websAssemblyModelSim")) websAssemblyModelSim <- tibble()

A <- get.adjacency(Lak_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Lak") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){

    message(paste("\ncalc_modularity_metaWebAssembly", fw, model_name))

    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)
    tbl <- calc_modularity_metaWebAssembly(websTbl, fw, A, f$m[1], f$a[1], f$se[1],1000)
    sim <- tbl$sim

    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network:Modularity)) %>%
                            dplyr::select(Network:Modularity,mdlCC:zMO)

    websAssemblyModel <<- websAssemblyModel %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSim <<-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()

```


## Plots of the distribution of simulated indices

```{r WeddellGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Plots of the distribution of simulated indices
#
net_name <- pull( websTbl %>% filter(!ismeta) %>% dplyr::select(Network) )
model_name <- "Prob"

# Add Conecctance to summary table websAssemblyModel
#
if( !("C" %in% names(websAssemblyModelSim)) ) { 
  websAssemblyModelSim <- websAssemblyModelSim %>% mutate(C = Links/(Size^2))
  websAssemblyModel <- websAssemblyModelSim %>% group_by(model,Network) %>% group_modify( ~{ qq <- quantile(.x$C,c(0.005,0.995))
                                                                        ss <- quantile(.x$Size,c(0.005,0.995))
                                                                        tibble(Clow = qq[1],Chigh=qq[2],Slow=ss[1],Shigh=ss[2])
                                                                        }) %>% inner_join( websAssemblyModel )
}
require(RColorBrewer)
col <- brewer.pal(8,"Dark2")
col <- c("#0097A7","#448AFF","#212121")


#
# Plots for All Networks
#
require(cowplot)

lapply(net_name, function(fw){

  dat <- websAssemblyModel %>% filter(Network==fw,model=="Prob") %>% rename(modularity=Modularity,C=Connectance) %>%
    bind_cols(websTbl %>% filter(Network==fw) %>% dplyr::select(Q,mTI))
  sim <- websAssemblyModelSim %>% filter(Network==fw,model=="Prob") 
  
  p1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=SWness, y=85, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=55, yend = 0), colour=col[2], size=.8, linetype=1 )
  
  p2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=Q, y=30, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[2], size=.8, linetype=1 )
  
  p3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=mTI, y=25, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=18, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=18, yend = 0), colour=col[2], size=.8, linetype=1 )
  
  
  p4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
      geom_segment(data=dat,aes(xend=modularity, y=25, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=18, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=18, yend = 0), colour=col[2], size=.8, linetype=1 )
  
  p5 <- ggplot(sim,aes(C))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=C, y=85, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=Clow,xend=Clow, y=18, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=Chigh,xend=Chigh, y=18, yend = 0), colour=col[2], size=.8, linetype=1 )

  p6 <- plot_grid(p5,p2+ylab(""),p3+ylab(""),p4+ylab(""),p1+ylab(""),align = "h",nrow=1)
  
  save_plot(paste0("Figures/",fw,"_Metrics_assembly_mdl.png"),p6,base_width=8,base_height=4,dpi=600)
})


lapply(net_name, function(fw){

  dat <- websAssemblyModel %>% filter(Network==fw,model=="Prob") %>% rename(modularity=Modularity,C=Connectance) %>%
    bind_cols(websTbl %>% filter(Network==fw) %>% dplyr::select(Q,mTI))
  sim <- websAssemblyModelSim %>% filter(Network==fw,model=="Prob") 
  
  h <- hist(sim$Size)
  y_end <- round(max(h$counts)* .12)
  y_end1 <- round(max(h$counts)* .08)
  
  p2 <- ggplot(sim,aes(Size))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=Size, y=y_end, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=Slow,xend=Slow, y=y_end1, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=Shigh,xend=Shigh, y=y_end1, yend = 0), colour=col[2], size=.8, linetype=1 )

  h <- hist(sim$C)
  y_end <- round(max(h$counts)* .12)
  y_end1 <- round(max(h$counts)* .08)
  
  p5 <- ggplot(sim,aes(C))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=C, y=y_end, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=Clow,xend=Clow, y=y_end1, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=Chigh,xend=Chigh, y=y_end1, yend = 0), colour=col[2], size=.8, linetype=1 )

  p6 <- plot_grid(p2,p5+ylab(""),align = "h",nrow=1)
  
  save_plot(paste0("Figures/",fw,"_CS_assembly_mdl.png"),p6,base_width=8,base_height=4,dpi=600)
})

#
# Table with Significance: empirical value is outside CI = TRUE 
#
names(websAssemblyModel)
sign <- websAssemblyModel %>% rename(modularity=Modularity,C=Connectance) %>% inner_join(websTbl %>% dplyr::select(Network,Q)) %>% transmute( C_sign = C > Chigh  | C < Clow, S_sign= Size> Shigh | Size< Slow, MO_sign = modularity > MOhigh | modularity < MOlow,TI_sign = TLmean > TIhigh | TLmean < TIlow, Q_sign = Q > Qhigh | Q < Qlow, SWness_sign = SWness > SWnessCI )

#
# Example Plot for the Figure 1 
#
# dat <- websAssemblyModel %>% filter(Network==net_name[1],model=="Prob") %>% rename(modularity=Modularity,C=Connectance) %>% bind_cols(websTbl %>% filter(Network==net_name[1]) %>% dplyr::select(Q,mTI))
# sim <- websAssemblyModelSim %>% filter(Network==net_name[1],model=="Prob") 
# 
# p <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_classic() + xlab("Network metric")
# p + geom_segment(data=dat,aes(x=Q+0.4,xend=Q+0.4, y=30, yend = 0), colour=col[2], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[3], size=1, linetype=1 ) +
#     geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[3], size=1, linetype=1 )
    
# dat <- websAssemblyModel %>% filter(Network==net_name[2],model=="Prob") %>% rename(modularity=Modularity) %>% bind_cols(websTbl %>% filter(Network==net_name[1]) %>% dplyr::select(Q,mTI))
# sim <- websAssemblyModelSim %>% filter(Network==net_name[2],model=="Prob")
# 
# q1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
#     geom_segment(data=dat,aes(xend=SWness, y=185, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=120, yend = 0), colour=col[2], size=1, linetype=1 )
# 
# 
# q2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
#     geom_segment(data=dat,aes(xend=Q, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
#     geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )
# 
# q3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
#     geom_segment(data=dat,aes(xend=mTI, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
#     geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )
# 
# 
# q4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
#     geom_segment(data=dat,aes(xend=modularity, y=24, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=16, yend = 0), colour=col[2], size=1, linetype=1 ) +
#     geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=16, yend = 0), colour=col[2], size=1, linetype=1 )
# 
# 
# require(cowplot)
# p5 <- plot_grid(q1+xlab(""),q2+ylab("")+xlab(""),q3+ylab("")+xlab(""),q4+ylab("")+xlab(""),
#                 p1,p2+ylab(""),p3+ylab(""),p4+ylab(""),align = "h",nrow=2,labels = c("Potter","","","","Wedell"))
# save_plot("Figures/Ant_Prop_assembly_ByNetwork.png",p5,base_width=8,base_height=5,dpi=600)



```


# Antarctic Metaweb assembly model QSS

```{r AntQSSMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
#if(!exists("websAssemblyModelQSS")) 
websAssemblyModelQSS <- tibble()
#if(!exists("websAssemblyModelSimQSS")) 
websAssemblyModelSimQSS <- tibble()

A <- get.adjacency(Ant_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Ant") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_qss_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name) %>% inner_join(websTbl %>% dplyr::select(Network,QSS,MEing))
    tictoc::tic("calc_qss_metaWebAssembly")
    tbl <- calc_qss_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000,ncores=48)
    tictoc::toc()
    sim <- tbl$sim
    
    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network,QSS,MEing)) 

    websAssemblyModelQSS <<- websAssemblyModelQSS %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSimQSS <<-websAssemblyModelSimQSS %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()

```

# Islands Metaweb assembly model QSS

```{r IslQSSMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModelQSS")) websAssemblyModelQSS <- tibble()
if(!exists("websAssemblyModelSimQSS")) websAssemblyModelSimQSS <- tibble()

A <- get.adjacency(Isl_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Isl") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_qss_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name) %>% inner_join(websTbl %>% dplyr::select(Network,QSS,MEing))
    tictoc::tic("calc_qss_metaWebAssembly")
    # (red, Adj, mig,ext,sec,nsim=1000,final_time=1000,ncores=0)
    tbl <- calc_qss_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000,ncores=48)
    tictoc::toc()
    sim <- tbl$sim
    
    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network,QSS,MEing)) 

    websAssemblyModelQSS <<- websAssemblyModelQSS %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSimQSS <<-websAssemblyModelSimQSS %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()


```

#  Lakes Metaweb assembly model QSS

```{r LakQSSMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModelQSS")) websAssemblyModelQSS <- tibble()
if(!exists("websAssemblyModelSimQSS")) websAssemblyModelSimQSS <- tibble()

A <- get.adjacency(Lak_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Lak") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_qss_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name) %>% inner_join(websTbl %>% dplyr::select(Network,QSS,MEing))
    tictoc::tic("calc_qss_metaWebAssembly")
    tbl <- calc_qss_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000,ncores=48)
    tictoc::toc()
    sim <- tbl$sim
    
    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network,QSS,MEing)) 

    websAssemblyModelQSS <<- websAssemblyModelQSS %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSimQSS <<-websAssemblyModelSimQSS %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()
```

# All Metrics - S and C and MEing - results Plots & tables  

```{r PotterMotifMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Table with Significance: empirical value is outside CI = TRUE 
#
websAssemblyModel <-  websAssemblyModel %>% select(model:zMO) %>% inner_join(websAssemblyModelQSS)
sign <- websAssemblyModel %>% rename(modularity=Modularity,C=Connectance) %>% inner_join(websTbl %>% dplyr::select(Network,Q)) %>% transmute( C_sign = C > Chigh  | C < Clow, S_sign= Size> Shigh | Size< Slow, MO_sign = modularity > MOhigh | modularity < MOlow,TI_sign = TLmean > TIhigh | TLmean < TIlow, Q_sign = Q > Qhigh | Q < Qlow, SWness_sign = SWness > SWnessCI , MEing_gt = MEing > MEingHigh  , MEing_lw = MEing < MEingLow )

knitr::kable(sign)

knitr::kable(websAssemblyModel %>% inner_join(websTbl %>% dplyr::select(Network,Q)) %>% select(Size, Slow,Shigh,Connectance,Clow,Chigh,TLmean,TIlow,TIhigh,Q,Qlow,Qhigh,MEing,MEingLow,MEingHigh))

names(websAssemblyModel)
names(websAssemblyModelQSS)
websAssemblyModelQSS  %>% mutate( MEing_gt = MEing > MEingHigh  , MEing_lw = MEing < MEingLow) %>% filter(MEing_gt | MEing_lw)


names(websAssemblyModelSimQSS)
metaweb_name <- "Ant"

websAssemblyModelSimQSS %>% filter((grepl(metaweb_name,Network))) %>% mutate(C=Links/(Size^2)) %>%
ggplot( aes(C,MEing))+ geom_point(size=1,alpha=0.5) + stat_ellipse(aes(color=Network)) + theme_bw() +
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network),!ismeta), aes(Connectance,MEing,color=Network),size=0.5) + 
  # coord_cartesian(ylim=c(0.01,0.1)) +  
  facet_wrap(~ Network) + scale_color_brewer(palette= "Paired", guide=FALSE) 


websAssemblyModelSimQSS %>% filter((grepl(metaweb_name,Network))) %>% mutate(C=Links/(Size^2)) %>%
ggplot( aes(Size,MEing))+ geom_point(size=1,alpha=0.5) + stat_ellipse(aes(color=Network)) + theme_bw() +
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network),!ismeta), aes(Size,MEing,color=Network),size=0.5) + 
  # coord_cartesian(ylim=c(0.01,0.1)) +  
  facet_wrap(~ Network) + scale_color_brewer(palette= "Paired", guide=FALSE) 

nets <- c("Lak_Bridge_brook_lake","Lak_Chub_pond", "Lak_Hoel_lake","Lak_Long_Lake")
websAssemblyModelSimQSS %>% filter(Network %in% nets) %>% mutate(C=Links/(Size^2)) %>%
ggplot( aes(Size,MEing))+ geom_point(size=1,alpha=0.5) + stat_ellipse(aes(color=Network)) + theme_bw() +
  geom_point(data=websTbl %>% filter(Network %in% nets), aes(Size,MEing,color=Network),size=1,alpha=1) + 
  # coord_cartesian(ylim=c(0.01,0.1)) +  
  facet_wrap(~ Network) + scale_color_brewer(palette= "Paired", guide=FALSE) 

#
# 
#
websAssemblyModelQSS <- websAssemblyModelQSS %>% select(Network,model, everything()) %>%  mutate(Metaweb=str_sub(Network,1,3))
require(tidyverse)
ggplot(websAssemblyModelQSS, aes(x=fct_reorder(Network,-MEing),y=MEing,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ theme_bw() + ylab("MEing")  + xlab(NULL) + geom_errorbar(aes(ymin=MEingLow, ymax=MEingHigh), width=.10) +   theme(axis.text.x=element_blank())
ggsave("Figures/MEing_Assembly_byMeta.png",width=8,height=6,units="in",dpi=600)


names( websAssemblyModel)

websAssemblyModel %>% inner_join(websTbl %>% dplyr::select(Network,Q))  %>% 
  ggplot( aes(x=fct_reorder(Network,-Q),y=Q,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Q")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=Qlow, ymax=Qhigh), width=.10) +   
  theme(axis.text.x=element_blank())
ggsave("Figures/Q_Assembly_byMeta.png",width=6,height=6,units="in",dpi=600)


websAssemblyModel %>% 
  ggplot( aes(x=fct_reorder(Network,-Modularity),y=Modularity,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Modularity")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=MOlow, ymax=MOhigh), width=.10) +   
  theme(axis.text.x=element_blank())
ggsave("Figures/Modularity_Assembly_byMeta.png",width=6,height=6,units="in",dpi=600)


websAssemblyModel %>% 
  ggplot( aes(x=fct_reorder(Network,-TLmean),y=TLmean,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Mean Trophic Level")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=TIlow, ymax=TIhigh), width=.10) +   
  theme(axis.text.x=element_blank())
ggsave("Figures/TL_Assembly_byMeta.png",width=6,height=6,units="in",dpi=600)


websAssemblyModel %>% 
  ggplot( aes(x=fct_reorder(Network,-Connectance),y=Connectance,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Connectance")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=Clow, ymax=Chigh), width=.10) +   
  theme(axis.text.x=element_blank())
ggsave("Figures/Connectance_Assembly_byMeta.png",width=8,height=6,units="in",dpi=600)


websAssemblyModel %>% 
  ggplot( aes(x=fct_reorder(Network,-Size),y=Size,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Size")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=Slow, ymax=Shigh), width=.10) +   
  theme(axis.text.x=element_blank())
ggsave("Figures/Size_Assembly_byMeta.png",width=8,height=6,units="in",dpi=600)


# + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)



```


# Motif Antarctic compared to  metaWeb assembly model 

```{r AntMotifMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}

#if(!exists("websAssemblyModelQSS")) 
motif_AssemblyModel <- tibble()

A <- get.adjacency(Ant_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Ant") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_motif_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)  %>% inner_join(motif_ER %>% dplyr::select(Network,explComp:omnivory))
    tictoc::tic("calc_motif_metaWebAssembly")
    tbl <- calc_motif_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()

    tblMdlWeb <- tbl %>% mutate(Network=fw,model=model_name) %>% select(Network, model, everything())

    motif_AssemblyModel <<- motif_AssemblyModel %>% bind_rows(tblMdlWeb) 
})
save.image()
```


# Motif Islands compared to  metaWeb assembly model 

```{r IslMotifMetaWebAssembly, eval=TRUE,echo=F,message=FALSE,warning=T}

#if(!exists("websAssemblyModelQSS")) 
#motif_AssemblyModel <- tibble()

A <- get.adjacency(Isl_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Isl") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_motif_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)  %>% inner_join(motif_ER %>% dplyr::select(Network,explComp:omnivory))
    tictoc::tic("calc_motif_metaWebAssembly")
    tbl <- calc_motif_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()

    tblMdlWeb <- tbl %>% mutate(Network=fw,model=model_name) %>% select(Network, model, everything())

    motif_AssemblyModel <<- motif_AssemblyModel %>% bind_rows(tblMdlWeb) 
})
save.image()
```

# Motif Lakes compared to  metaWeb assembly model 

```{r LakMotifMetaWebAssembly, eval=TRUE,echo=F,message=FALSE,warning=T}

#if(!exists("websAssemblyModelQSS")) 
#motif_AssemblyModel <- tibble()

A <- get.adjacency(Lak_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Lak") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_motif_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)  %>% inner_join(motif_ER %>% dplyr::select(Network,explComp:omnivory))
    tictoc::tic("calc_motif_metaWebAssembly")
    tbl <- calc_motif_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()

    tblMdlWeb <- tbl %>% mutate(Network=fw,model=model_name) %>% select(Network, model, everything())

    motif_AssemblyModel <<- motif_AssemblyModel %>% bind_rows(tblMdlWeb) 
})
save.image()
```



# Tables Motif compared to  metaWeb assembly model 

```{r TablesMotifMetaWebAssembly, eval=FALSE,echo=F,message=T,warning=T}

#
# Table with Significance: empirical value is outside CI = TRUE 
#
sign <- motif_AssemblyModel %>% transmute( Network=Network, zEC = explComp > EChigh  | explComp < EClow, zAC= apprComp> AChigh | apprComp< AClow, zTT = triTroph > TThigh | triTroph < TTlow, zOM = omnivory > OMhigh | omnivory < OMlow)


# Plot of random z-score motif normalized
#
#

require(tidyr)
names(motif_AssemblyModel)
pFM1 <- motif_AssemblyModel %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,Zscore,zEC:zOM) %>% mutate(type="Random z-score")
pFM1$Network <- factor(pFM1$Network)
#levels(pFM1$Network) <- c("Potter Cove","Meta-web","Weddell Sea")

# Normalize z-scores
#
pFM1 <- pFM1 %>% group_by(Network) %>% mutate(normZ=Zscore/sum(sqrt(Zscore^2)), Metaweb=str_sub(Network,1,3)) 
 

# Add asteriscs to significative motifs
#

sign_lbl <- sign %>% pivot_longer(!Network,values_to = "sign",names_to = "motif") %>% mutate(label=ifelse(sign, "*", "")) %>% inner_join(pFM1) %>% mutate( Network = gsub('([a-z])([A-Z])', '\\1 \\2', str_sub(Network,5)) %>% str_replace_all('_',' ' ))

g1 <- ggplot(sign_lbl,
        aes(x=fct_inorder(Network),y=Zscore,fill=motif,label=label)) + geom_bar(stat="identity",position=position_dodge()) +
   scale_fill_brewer(palette = "Paired",breaks=c("zAC","zEC","zOM","zTT"),name="Motif\nZ-score",   labels=c("Apparent\ncompetition","Exploitative\ncompetition","Omnivory", "Tri-trophic\nchain")) + #guides(fill=FALSE) +
   xlab("") + ylab("") + theme_bw() +  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size=7)) + 
  #facet_wrap(~Metaweb, ncol = 1, scale="free") + 
  geom_text(position=position_dodge(width=0.9))
g1
ggsave("Figures/Motif_Zscores_Assembly.png",width=8,height=6,units="in",dpi=600)



```

# Topological roles with meta-web assembly model 

```{r MetaWebTopologicalRoles, eval=FALSE,echo=F,message=T,warning=T}

# Check the correct meta-web adjacency matrix is loaded

dim(A)==c(859,859)

#
# 500 time steps 
#
tf <- 500
set.seed(1234)

# Weddell Sea 
#
#
m <- 0.084 
a <- 0.076
tf <- 531
AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
dfA$S[tf-200]
plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

g <- graph_from_adjacency_matrix( AA$A, mode  = "directed")

# Select only a connected subgraph graph 
#
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
vcount(g)
modulos<-cluster_spinglass(g)

topoRoles_metaWebAssembly <- calc_avg_topological_roles(g,"Weddell",10)   # 30 simulations are enough to obtain stable topological roles

# Initialize hub_conn
hub_conn_Assembly <- data.frame()

# Plot and clasify topological roles
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(topoRoles_metaWebAssembly,g,modulos) %>% mutate(Network="Weddell"))

plotTopoRolesByTLByMod("","Weddell","",modulos,hub_conn_Assembly,"",g)


# Potter Cove Simulations
#
#

set.seed(123)
m <- 0.023
a <- 0.094
tf <- 546

AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))

plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

AA$S[tf]

g <- graph_from_adjacency_matrix( AA$A*1, mode  = "directed")
# Add Names
#V(g)$label <- rownames(A)

# Select only a connected subgraph graph 
#
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
#plot(g,edge.arrow.size=.4,edge.color="orange", vertex.color="gray50",vertex.size=3,layout=layout_with_fr)
vcount(g)
sum(degree(g,mode="in")==0)
V(g)[degree(g,mode="in")==0]$label

modulos<-cluster_spinglass(g)

tR <- calc_avg_topological_roles(g,"Potter",10)
topoRoles_metaWebAssembly <- bind_rows(topoRoles_metaWebAssembly,tR )


# Plot and clasify topological roles
#
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(tR,g,modulos) %>% mutate(Network="Potter"))

plotTopoRolesByTLByMod("","Potter","",modulos,hub_conn_Assembly,"",g)

save.image()

# Topological Roles proportions test and plot
#
#
names(hub_conn)


tbl <- table(hub_conn$Network,hub_conn$type)

tbl1 <- table(hub_conn_Assembly$Network,hub_conn_Assembly$type)
tbl1 <- rbind(tbl,tbl1) 
tbl1 <- tbl1[c(2,4,5),]
class(tbl1) <- "table"

chisq.test(tbl1,simulate.p.value = TRUE, B=10000)

require(ggplot2)
require(scales)
df1 <- data.frame(tbl1) 
names(df1) <- c("Network","Rol","count")
df1 <- filter(df1,count!=0)
df1 <- df1 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df1$Network <- factor(df1$Network, levels=c("Potter","Weddell","Meta")) 

levels(df1$Network) <- c("Potter Cove\nModel","Weddell Sea\nModel","Meta-web")


gP1 <- ggplot(df1,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")


# Proportion of topo roles of the real networks
#
df2 <- data.frame(tbl,stringsAsFactors = FALSE)
names(df2) <- c("Network","Rol","count")
df2 <- filter(df2,count!=0)
df2 <- df2 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df2$Network <- factor(df2$Network, levels=c("Local","Regional","Meta")) 
levels(df2$Network) <- c("Potter Cove","Weddell Sea","Meta-web")

gP2 <- ggplot(df2,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")

legend_b <- get_legend(gP2 + theme(legend.position="bottom"))

require(cowplot)
gP3 <- plot_grid(gP2,gP1,labels = c("A","B"),align = "h")
gP3 <- plot_grid( gP3, legend_b, ncol = 1, rel_heights = c(1, .05))
save_plot("Figures/PropRoles_ByNetwork_Model.png",gP3,base_width=8,base_height=5,dpi=600)
#ggsave("Figures/PropMotif_Roles_ByNetwork.png",width=8,height=5,units="in",dpi=600)

save.image()
```

