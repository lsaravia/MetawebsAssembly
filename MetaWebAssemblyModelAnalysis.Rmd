---
title: "From metawebs to regional and local"
author: "L.A.S."
output: html_document
editor_options: 
  chunk_output_type: console
---

## Setup

- I run the analysis setting `eval=True` or `eval=False` to run a particular chunk, not the whole Rmd, e.g. to fit the model first I read the dataset then I run the fitting procedure.  

```{r setup, echo=FALSE }
if(file.exists(".RData")) load(".RData")

needed_packages <- c(
    "ggplot2"
  , "igraph"
  , "dplyr"
  , "stringr"
  , "devtools")

lapply(needed_packages, function(x) { if(!require(x,character.only = TRUE)){ install.packages(x) }} )

theme_set(theme_bw())

if( require(meweasmo) == FALSE)
  install_github("lsaravia/meweasmo")
if( require(multiweb) == FALSE)
  install_github("lsaravia/multiweb")

source("R/network_fun.r")

```

# Read Antarctic Networks

```{r readAntarctic, eval=FALSE,echo=F,message=T,warning=T}
#
# Read the Antarctic Metawebs files with New Weddell from @Brose2019 (GATEWAy database)
#
dn <- list.files("Data",pattern = "^[MWP].*\\.dat$")
dn <- paste0("Data/", dn)
dn <- dn[c(2,3,1)]
ig_list <- readNetwork(dn,edgeListFormat=2)
names(ig_list) <- c("Ant_Potter","Ant_Weddell","Ant_Meta")

redl <- ig_list[["Ant_Meta"]] 
sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network=="Ant_Meta") %>% select(Basal)

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]
```


## Read the Islands data set 

```{r readIslands, eval=TRUE,echo=TRUE,message=FALSE }

#
# Extract Weddell Sea from GATEWAy database
#
ga <- readr::read_csv("~/Dropbox/Projects/MetaWebsAssembly/Data/283_2_FoodWebDataBase_2018_12_10.csv",col_types = "icccccccccccccddddddccccccccddddddcddccddciicc")

fw_name <- ga %>% filter(grepl("Piechnik",link.citation )) %>% distinct(foodweb.name)                
Have_df <- ga %>% filter(grepl("Piechnik",link.citation )) %>% dplyr::select(con.taxonomy,con.taxonomy.level,res.taxonomy,res.taxonomy,foodweb.name)
require(igraph)
dtot1 <- as.matrix(Have_df %>% dplyr::select(res.taxonomy,con.taxonomy))
have1  <- graph_from_edgelist(dtot1, directed  = T)

df_list <- Have_df %>% group_split(foodweb.name)
ig_list <- lapply(df_list, function(fw) {
  d1 <- as.matrix(fw %>% dplyr::select(res.taxonomy,con.taxonomy))
  graph_from_edgelist(d1, directed  = T)
})
names(ig_list) <- paste0("Isl_",fw_name$foodweb.name)
ig_list <- c(ig_list, list(Isl_Meta=have1))

redl <- ig_list[["Isl_Meta"]] 

stopifnot(sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network=="Isl_Meta") %>% select(Basal))

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]

```


# Check the steady state of the model    

```{r checkSteadyState, eval=F,echo=F,message=T,warning=T}


set.seed(2312)
#
# Testing if 500 time steps is enough to find equilibrium point
#
#
# Testing for the CT model
#
tf <- 3000
m <- rep(0.1,times=dimA)
e <- rep(0.3, times=dimA)
se <- rep(0.3, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP <- plot_NetAssemblyModel_eqw(AA,50)
AAdf <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 1500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
AAdf1 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 1000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP1 <- plot_NetAssemblyModel_eqw(AA,50)
AAdf2 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf3 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
AAdf4 <- tibble(C=AA$L[2:100]/ (AA$S[2:100])^2 ,S=AA$S[2:100]) %>% mutate(mC = mean(C), mS=mean(S)) 

require(ks)
kde.test(AAdf3[,1:2],AAdf[,1:2])$pvalue
# [1] 0.2421669
kde.test(AAdf3[,1:2],AAdf1[,1:2])$pvalue
# [1] 0.5166524
kde.test(AAdf3[,1:2],AAdf2[,1:2])$pvalue
# [1] 0.2582594
##
# Testing the first 100 time steps against the last 100 of the '500' simulation
kde.test(AAdf4[,1:2],AAdf3[,1:2])$pvalue
# [1] 0.05814453

AAdfTot <- bind_rows(AAdfTot, 
                     bind_rows(AAdf %>% mutate(Sim="2000"), AAdf1 %>% mutate(Sim="1500"), AAdf2 %>% mutate(Sim="1000"), AAdf3 %>% mutate(Sim="500")) %>% mutate(model_type="Continuous")
                     )
ggplot(AAdfTot, aes(S,C,color=Sim))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)

#
# Changing parameters
#
#
# Testing if 500 time steps is enough to find equilibrium point
#
set.seed(2312)

t_window <-  100
tf <- 3000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP2 <- plot_NetAssemblyModel_eqw(AA,50)
AAdf <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 


tf <- 1500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf1 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 

tf <- 1000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP3 <- plot_NetAssemblyModel_eqw(AA,50)

AAdf2 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 


tf <- 5000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf4 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 

tf <- 500
t_window <- 100
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf3 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 


#
# Kernel density based global two-sample comparison test 2d 
# to determine if the last 100 time steps have the same distribution of C and S 
# and therefore there is steady state
#
require(ks)
kde.test(AAdf3[,1:2],AAdf[,1:2])$pvalue
# [1] 0.5316762
kde.test(AAdf3[,1:2],AAdf1[,1:2])$pvalue
# 0.3481172
kde.test(AAdf3[,1:2],AAdf2[,1:2])$pvalue
# [1] 0.1103454
#
# There are differences p<0.05 due to the ciclic dynamics

AAdf <- bind_rows(AAdf , AAdf1, AAdf2, AAdf3,AAdf4) %>% mutate(model_type="Continuous",e=0.005)
AAdfTot <- bind_rows(AAdfTot,AAdf)
ggplot(AAdf , aes(S,C,color=factor(Sim)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)

#  + theme(axis.text.x=element_blank(),axis.title.x=element_blank())
gP5 <- plot_grid(gP$g1,
                 gP$g2,
                 gP1$g1 ,
                 gP1$g2 ,
                 align = "hv",
                  ncol = 2)
save_plot("Figures/Metaweb_steady_state_Potter.png",gP5,base_width=6,base_height=6,dpi=600)

gP5 <- plot_grid(gP2$g1 ,
                 gP2$g2 ,
                 gP3$g1 ,
                 gP3$g2 ,
                 align = "hv",
                  ncol = 2)

save_plot("Figures/Metaweb_steady_state_Weddell.png",gP5,base_width=6,base_height=6,dpi=600)


#ggsave("Figures/Metaweb_SteadyState_byModel.png",width=8,height=5,units="in",dpi=600)

```

* The discrete time and continuous time models give the same results, this is a verification that the models are well implemented and that the timmings of events have no influence on the results. So we keep using the discrete time model.  


# Checking differences with m and a parameters, to know if we can use lambda=m/a as a unique parameter

```{r checklambda, eval=F,echo=F,message=T,warning=T}



#
# Testing if there are difference with different m/e 
#      m      a     S     L      C    se model     model_type alpha distance min_dist
# 0.0263 0.106   92.1  324. 0.0383 0.691 Prob      Continuous 0.247  0.00339 TRUE    
# 0.0145 0.0522  91.4  322. 0.0385 0.254 Prob      NA         0.278  0.00786 TRUE    

AAdf <- tibble()
set.seed(2312)

tf <- 1000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=0.25,model_type="Discrete") )


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),se=0.25,e=0.05,model_type="Discrete") )

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)


# 
# Continous time 0.0263 0.106   92.1  324. 0.0383 0.691
#
tf <- 1000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),se=0.25,e=0.005,model_type="Continuous"))


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),se=0.25,e=0.05,model_type="Continuous"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~model_type)


#
# se = 1 
#
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=1,model_type="Discrete")) 


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=1,model_type="Discrete"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( se ~ model_type)


# 
# Continous time 0.0263 0.106   92.1  324. 0.0383 0.691
#
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=1,model_type="Continuous"))


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=1,model_type="Continuous"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) +
  facet_grid( se ~ model_type)

#
# se = 0 
#
tf <- 1000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=0,model_type="Discrete")) 


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=0,model_type="Discrete"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( se ~ model_type)


# 
# Continous time 0.0263 0.106   92.1  324. 0.0383 0.691
#
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=0,model_type="Continuous"))


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=0,model_type="Continuous"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) +
  facet_grid( se ~ model_type)


ggsave("Figures/Metaweb_SecExtc_byModel.png",width=8,height=5,units="in",dpi=600)

```

* there are differences when secondary extinctions are >0 and mainly in the temporal SD so we keep using the 2 parameters


# Antarctic Metaweb Simulate a grid of parameters to select the best options


```{r makeSimulations150000tf1000, eval=FALSE,echo=F,message=T,warning=T}

metaweb_name <-  "Ant_Meta"

# Check redl is the metaweb
# 
stopifnot(  sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network==metaweb_name) %>% select(Basal) )

metaweb_name <- str_sub(metaweb_name,1,3)


A <- get.adjacency(redl,sparse=F)
dimA <- nrow(A)

# Simulate a grid of parameters to select the best options using latin hypercubic sampling
#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
#
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)
simMetaWebAssembly <- tibble()
# simulations with probability of secondary extinction == 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2, 150000, par_ranges,A, 1 ) %>% mutate(model_type="Continuous",Metaweb="Ant")

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction != 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A, 1) %>% mutate(model_type="Continuous",Metaweb="Ant")

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")


# simulations with probability of secondary extinction == 0
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  150000, par_ranges,A,1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# Set the type of models according to probability of secondary extinction
#
simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ))
knitr::kable(simMetaWebAssembly %>% group_by(model,model_type) %>% summarise(n=n()))

p1 <- ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Connectance,color=Network),size=0.5) + 
  coord_cartesian(ylim=c(0.01,0.1)) +  
  facet_wrap(~ model) + scale_color_brewer(palette= "Paired", guide=FALSE)

ggplot(simMetaWebAssembly, aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl, aes(Size,Links,color=Network),size=0.3) + coord_cartesian(ylim=c(0,3000)) + facet_wrap(~model)

# ggplot(simMetaWebAssembly %>% filter(model=="Prob"), aes(S,C,color=model_type))+ geom_point(size=.1,alpha=0.5) + theme_bw() + coord_cartesian(ylim=c(0,0.1)) + scale_color_brewer(palette= "Dark2",name="")#, labels=c("Fixed Sec.Ext.", "Potter","Meta", "No Sec.Ext.", "Prob. Sec.Ext.","Weddell" ))  
# ggsave("Figures/Metaweb_Continuous_Discrete.pdf",width=8,height=5,units="in",dpi=600)


ggplot(simMetaWebAssembly %>% filter(model=="Prob"), aes(S,C,color=model_type))+ geom_point(size=.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Connectance,color=Network),size=0.4) + coord_cartesian(ylim=c(0,0.1)) + scale_color_brewer(palette= "Dark2",name="")#, labels=c("Fixed Sec.Ext.", "Potter","Meta", "No Sec.Ext.", "Prob. Sec.Ext.","Weddell" ))  
rm(sim,par_ranges,AAdf,AAdf1,AAdf2,AAdf3,AAdf4,AAdfTot,f)
save.image()
```


## Make the fit finding the parameters with less distance to empirical networks

```{r fitMetaWebPC50002, eval=FALSE,echo=F,message=T,warning=T}


#
# Potter Cove
#
# Use this tolerance = tol to display a more detailed plot 
fittedMetaWeb <- fit_metaWebAssembly_model(websTbl, "Ant_Potter", simMetaWebAssembly)
fittedMetaWeb <- bind_rows(fittedMetaWeb, fit_metaWebAssembly_model(websTbl, "Ant_Weddell", simMetaWebAssembly))


knitr::kable(fittedMetaWeb %>% dplyr::select( Network,  everything(), -min_dist) %>% arrange(Network))

rm(X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ravg,sel,redl,ig_list,web)
save.image()

```


* Fit of Metaweb model by variant usin C and S

|Network     |         m|         a|        se|         S|         L|         C|model_type |Metaweb |model     |     alpha|  distance|fit_type |
|:-----------|---------:|---------:|---------:|---------:|---------:|---------:|:----------|:-------|:---------|---------:|---------:|:--------|
|Ant_Potter  | 0.0185036| 0.1269833| 0.0000000|  92.35644|  325.1782| 0.0381230|Continuous |Ant     |No SecExt | 0.1457165| 0.0081407|S-C      |
|Ant_Potter  | 0.0409665| 0.2375224| 0.2219146|  94.87129|  367.0495| 0.0407807|Continuous |Ant     |Prob      | 0.1724744| 0.0694620|S-C      |
|Ant_Potter  | 0.0144288| 0.0864320| 1.0000000|  87.28713|  331.4554| 0.0435036|Continuous |Ant     |Fixed     | 0.1669378| 0.1424930|S-C      |
|Ant_Weddell | 0.0207792| 0.0131341| 0.4088838| 446.70297| 7646.4554| 0.0383197|Continuous |Ant     |Prob      | 1.5820785| 0.4354927|S-C      |
|Ant_Weddell | 0.0139139| 0.0096195| 1.0000000| 441.68317| 7272.8218| 0.0372805|Continuous |Ant     |Fixed     | 1.4464271| 0.4528557|S-C      |
|Ant_Weddell | 0.0298641| 0.0259663| 0.0000000| 444.68317| 6772.1485| 0.0342472|Continuous |Ant     |No SecExt | 1.1501116| 0.4960883|S-C      |



# Islands Metaweb Simulate a grid of parameters to select the best options


```{r IslandSimulations150000tf1000, eval=TRUE,echo=F,message=T,warning=T}

metaweb_name <-  "Isl_Meta"

# Check redl is the metaweb
# 
stopifnot(  sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network==metaweb_name) %>% select(Basal) )

metaweb_name <- str_sub(metaweb_name,1,3)

A <- get.adjacency(redl,sparse=F)
dimA <- nrow(A)

# Simulate a grid of parameters to select the best options using latin hypercubic sampling
#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
#
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)

# simulations with probability of secondary extinction == 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2, 150000, par_ranges,A, 1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction != 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A, 1) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")


# simulations with probability of secondary extinction == 0
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  150000, par_ranges,A,1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# Set the type of models according to probability of secondary extinction
#
#simMetaWebAssembly <- bind_rows(simMetaWebAssembly, readRDS("Data/simulations_metaWebAssembly.rds"))
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ))
knitr::kable(simMetaWebAssembly %>% group_by(Metaweb,model,model_type) %>% summarise(n=n()))

p2 <- ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Connectance,color=Network),size=0.5) + 
  coord_cartesian(ylim=c(0.05,.5)) + 
  facet_wrap(~ model) + scale_color_brewer(palette= "Paired",guide=FALSE)

ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Links,color=Network),size=0.3) + 
  coord_cartesian(ylim=c(0,3000)) + 
  facet_wrap(~model)  + scale_color_brewer(palette= "Dark2")

# ggsave("Figures/Metaweb_Continuous_Discrete.pdf",width=8,height=5,units="in",dpi=600)
```

## Make the fit Islands

```{r fitMetaWebPC50002, eval=FALSE,echo=F,message=T,warning=T}
#
#
# Use this tolerance = tol to display a more detailed plot 

netnames <- names(ig_list)
netnames <- netnames[ netnames != "Isl_Meta" ] 
fmw <-  lapply(netnames, function(n){

  fit_metaWebAssembly_model(websTbl, n, simMetaWebAssembly)
  
})

fittedMetaWeb <- bind_rows(fittedMetaWeb, fmw)


knitr::kable(fittedMetaWeb %>% dplyr::select( Network,  everything(), -min_dist) %>% arrange(Network))

rm(netnames,fmw,X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ravg,sel,redl,ig_list,web)
save.image()

```

FALTA HACER LAKES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# Make simulations with fitted parameters with S-C method

* As connectivity is determines most of other network properties we fit by connectivity and number of species

```{r fitMetaWebSims, eval=FALSE,echo=F,message=T,warning=T}

# Model with probability of secundary extinction se>0 & se<1
#
# Potter
#
tf <- 500
set.seed(1110) 
f <- fittedMetaWeb %>% filter(Network=="Potter")
mm <- rep(f$m[1],nrow(A))
aa <- rep(f$a[1],nrow(A))
se <- rep(f$se[1],nrow(A))
AA <- metaWebNetAssembly(A,mm,aa,se,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))

# Running averages
ravg <- tibble()
ravg <- bind_rows( ravg, plot_NetAssemblyModel_eqw(AA,50,"Figures/PotterCove_Meta-webSim_avg_Prob.pdf",websTbl[1,]) %>% mutate(Network = "Potter"))

# Time series plot
plot_NetAssemblyModel(AA,300,"Figures/PotterCove_Meta-webSim_ts_Prob.pdf",websTbl[1,])

#
# Weddell 
#

f <- fittedMetaWeb %>% filter(Network=="Weddell")

# Modelo Prob
# 
tf <- 500
set.seed(1110)
mm <- rep(f$m[3],nrow(A))
aa <- rep(f$a[3],nrow(A))
se <- rep(f$se[3],nrow(A))
AA <- metaWebNetAssembly(A,mm,aa,se,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
ravg <- bind_rows( ravg, plot_NetAssemblyModel_eqw(AA,50,"Figures/Weddell_Meta-webSim_avg_Prob.pdf",websTbl[2,]) %>% mutate(Network = "Weddell"))
plot_NetAssemblyModel(AA,300,"Figures/Weddell_Meta-webSim_ts_Prob.pdf",websTbl[2,])




rm(X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,ravg,dfA,dtot,dtot1,cl,sel,redl,e,ee,ext,aa,m,mig,mm,se,colTL,cn,colnet)
save.image()

  # Plot of five simulations 
#
gg <- plot_NetAssemblyModel(AA,100)

# Plot of S and C for Weddell 
#
require(cowplot)
g3 <- plot_grid(gg[[1]],gg[[3]],labels = c("A","B"),align = "h")
save_plot("Figures/Weddell_Meta-webSim_SC.png",g3,base_width=8,base_height=5,dpi=300)


```



# Local web (Potter Cove) compared to  metaWeb assembly model

* Ideas to compare is to select the simulations with the same C or Same S ?????

```{r PotterGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Read data and trim species names to avoid duplicates 
#
# dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
# dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))
# 
# #
# # Select meta web 
# #
# dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
# redl <- graph_from_edgelist(dtot1, directed  = T)
# # Delete cannibalistic 
# redl <- simplify(redl)
# sum(degree(redl,mode="in")==0)
# 
redl <- meta 
sum(degree(redl,mode="in")==0) == websTbl$Basal[3]

A <- get.adjacency(redl,sparse=F)
dim(A)                             

#
# Select Local food web 
# 
redl <- pott 
sum(degree(redl,mode="in")==0) == websTbl$Basal[1]

# dtot1 <- as.matrix(dtot %>% filter(Network=="Local") %>% dplyr::select(Prey_name,Predator_name))
# redl <- graph_from_edgelist(dtot1, directed  = T)

#
# Calculate Trophic Position
#
require(NetIndices)
TL <-TrophInd(get.adjacency(redl,sparse=F),Dead=c("Fresh detritus","Aged detritus","Necromass"))

#
# Compare modularity 
#
require(tictoc)
fittedMetaWeb$m[1]
fittedMetaWeb$a[1]

tic()
tbl <- calc_modularity_metaWebAssembly(redl, A, fittedMetaWeb$m[1],fittedMetaWeb$a[1],1000,TL)
toc()
sim <- tbl$sim
tblMdlWeb <- tbl$su %>% mutate(Network="Potter") %>% inner_join(dplyr::select(websTbl,Size:Modularity), by="Network")

#
# Calculate z-score of modularity
#
tblMdlWeb <- tblMdlWeb %>% mutate(zMO= (Modularity- mdlMO)/MOsd, zGR=(Groups-mdlGR)/(GRhigh-GRlow)*2)

websAssemblyModel <- dplyr::select(tblMdlWeb,Network:Modularity,mdlCC:zTI,zMO:zGR)

#
# Correct the calculation of z-score
#
websAssemblyModel$mdlMO[2] <- with(tblMdlWeb,mdlMO)
websAssemblyModel$zMO[2] <- with(tblMdlWeb, (Modularity- mdlMO)/MOsd)
rm(tbl)

websAssemblyModelSim <-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network="Potter"))  
save.image()



```



# Regional web (Weddell) compared to  metaWeb assembly model 

```{r WeddellGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Select "Regional" food web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Regional") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
redl <- simplify(redl)


require(NetIndices)
TL<-TrophInd(get.adjacency(redl,sparse=F),Dead=c("Detritus","Necromass"))

#
# Compare modularity 
#
require(tictoc)
m <- 0.084 
a <- 0.076
tic()
tbl <- calc_modularity_metaWebAssembly(redl, A, m,a,1000,TL)
toc()
sim <- tbl$sim

tblMdlWeb <- tbl$su %>% mutate(Network="Weddell") %>% inner_join(dplyr::select(websTbl,Size:Modularity), by="Network")

#
# Calculate z-score of modularity
#
tblMdlWeb <- tblMdlWeb %>% mutate(zMO= (Modularity- mdlMO)/MOsd, zGR=(Groups-mdlGR)/(GRhigh-GRlow)*2)

websAssemblyModel <- bind_rows(websAssemblyModel, dplyr::select(tblMdlWeb,Network:Modularity,mdlCC:zTI,zMO:zGR))

#
# Correct the calculation of z-score
#
# websAssemblyModel$mdlMO[1] <- with(tblMdlWeb,mdlMO)
# websAssemblyModel$zMO[1] <- with(tblMdlWeb, (Modularity- mdlMO)/MOsd)
websAssemblyModelSim <-  sim %>% mutate(Network="Weddell")


#
# Plots of the distribution of simulated indices
#
require(RColorBrewer)
col <- brewer.pal(8,"Dark2")
col <- c("#0097A7","#448AFF","#212121")
dat <- websAssemblyModel %>% filter(Network=="Regional") %>% rename(modularity=Modularity) %>% bind_cols(websTbl %>% filter(Network=="Weddell") %>% select(Q,mTI))

sim <- websAssemblyModelSim %>% filter(Network=="Weddell")
names(dat)
names(sim)
#
# Plot for the figure 1 
#
p <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_classic() + xlab("Network metric")
p + geom_segment(data=dat,aes(x=Q+0.4,xend=Q+0.4, y=30, yend = 0), colour=col[2], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[3], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[3], size=1, linetype=1 )


p1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=SWness, y=85, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=55, yend = 0), colour=col[2], size=1, linetype=1 )


p2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=Q, y=30, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[2], size=1, linetype=1 )

p3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=mTI, y=25, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=18, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=18, yend = 0), colour=col[2], size=1, linetype=1 )


p4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
    geom_segment(data=dat,aes(xend=modularity, y=25, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=18, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=18, yend = 0), colour=col[2], size=1, linetype=1 )


dat <- websAssemblyModel %>% filter(Network=="Local") %>% rename(modularity=Modularity) %>% bind_cols(websTbl %>% filter(Network=="Potter") %>% select(Q,mTI))

sim <- websAssemblyModelSim %>% filter(Network=="Potter")

q1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=SWness, y=185, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=120, yend = 0), colour=col[2], size=1, linetype=1 )


q2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=Q, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )

q3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=mTI, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )


q4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
    geom_segment(data=dat,aes(xend=modularity, y=24, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=16, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=16, yend = 0), colour=col[2], size=1, linetype=1 )


require(cowplot)
p5 <- plot_grid(q1+xlab(""),q2+ylab("")+xlab(""),q3+ylab("")+xlab(""),q4+ylab("")+xlab(""),
                p1,p2+ylab(""),p3+ylab(""),p4+ylab(""),align = "h",nrow=2,labels = c("A","","","","B"))
save_plot("Figures/globProp_assembly_ByNetwork.png",p5,base_width=8,base_height=5,dpi=600)



save.image()
```


# Motif Potter Cove compared to  metaWeb assembly model 

```{r PotterMotifMetaWebAssembly, eval=F,echo=F,message=T,warning=T}


#sourceCpp("src/NetAssemblyFromMetaWeb.cpp")

#
# Read data and trim species names to avoid duplicates 
#
dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))

#
# Select meta web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
# Delete cannibalistic 
redl <- simplify(redl)
sum(degree(redl,mode="in")==0)

A <- get.adjacency(redl,sparse=F)
dim(A)                             

#
# Select Local food web 
# 

dtot1 <- as.matrix(dtot %>% filter(Network=="Local") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)

#
# Motif
#
mot <- triad_census(redl)

mot[4] # Exploitative competition
mot[5] # Apparent competition
mot[6] # Tri-trophic chain
mot[9] # Omnivory

#FreqMotif <- data.frame(Network="Local",t(mot))

set.seed(123)
m <- 0.023
a <- 0.094
motif_metaWeb <- calc_motif_metaWebAssembly(redl, A, m,a,1000)

motif_metaWeb <- motif_metaWeb %>% mutate(Network="Local")


save.image()

```


# Motif Weddell compared to  metaWeb assembly model 

```{r WeddellMotifMetaWebAssembly, eval=FALSE,echo=F,message=T,warning=T}


#
# Select "Regional" food web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Regional") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
redl <- simplify(redl)


#
# Motif
#
set.seed(123)

m <- 0.084 
a <- 0.076
m_metaWeb <- calc_motif_metaWebAssembly(redl, A, m,a,1000)

motif_metaWeb <- bind_rows(motif_metaWeb, m_metaWeb %>% mutate(Network="Regional"))

rm(m_metaWeb)
save.image()


select(motif_metaWeb, explComp,EClow,EChigh)
select(motif_metaWeb, apprComp,AClow,AChigh,zAC)
select(motif_metaWeb, triTroph,TTlow,TThigh,zTT)
select(motif_metaWeb, omnivory,OMlow,OMhigh,zOM)

# Generate tables for the manuscript
#
#
require(pander)
panderOptions('table.split.table',Inf)
panderOptions('table.style', 'multiline')

webs_tmp <- inner_join(websAssemblyModel,dplyr::select(websTbl,Q,mTI,Network), by="Network")

pandoc.table(t(webs_tmp %>% dplyr::select(Network,SWness,SWnessCI,zQ,zTI,zMO,zGR,mTI) %>% mutate_if(is.numeric, round, digits=4)))


pandoc.table(t(webs_tmp %>% dplyr::select(Network,Q,Qlow,Qhigh,mTI,TIlow,TIhigh,Modularity, MOlow,MOhigh) %>% mutate_if(is.numeric, round, digits=4)))

pandoc.table(t(motif_metaWeb %>% rename(EC=explComp,AC=apprComp,TT=triTroph,OM=omnivory) %>%
                 dplyr::select(Network,EC,EClow,EChigh,zEC,AC,AClow,AChigh,zAC,TT,TTlow,TThigh,zTT,OM,OMlow,OMhigh,zOM) %>% mutate_if(is.numeric, round, digits=2)))


# Plot of random z-score motif normalized
#
#

require(tidyr)
names(motif)
pFM1 <- motif %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,value,zEC:zOM) %>% mutate(type="Random z-score")
pFM1$Network <- factor(pFM1$Network)
levels(pFM1$Network) <- c("Potter Cove","Meta-web","Weddell Sea")

# Normalize z-scores
#
pFM1 <- pFM1 %>% group_by(Network) %>% mutate(normZ=value/sum(sqrt(value^2)))
g1 <- ggplot(pFM1,aes(x=Network,y=normZ,fill=motif)) + geom_bar(stat="identity",position=position_dodge()) +
   scale_fill_brewer(palette = "Paired",breaks=c("zAC","zEC","zOM","zTT"),name="Motif\nZ-score",   labels=c("Apparent\ncompetition","Exploitative\ncompetition","Omnivory", "Tri-trophic\nchain")) + guides(fill=FALSE) +
   xlab("") + ylab("") + theme_bw() + scale_x_discrete(limits=c("Potter Cove","Weddell Sea","Meta-web")) + expand_limits(y=c(0.8,-0.35)) #+ theme(legend.position="bottom")

# Add asteriscs to significative motifs

sig_lbl <- pFM1 %>% mutate(normZ=ifelse(motif=="zTT", normZ-0.05,normZ+0.05) )
g1 <- g1 + geom_text(data = sig_lbl, label = "*",position=position_dodge(width=0.9))

# Plot of assembly motifs normalized 
#
names(motif_metaWeb)
pFM2 <- motif_metaWeb %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,value,zEC:zOM) %>% mutate(type="Assembly z-score", Network=factor(Network))

levels(pFM2$Network) <- c("Potter Cove","Weddell Sea")

pFM2 <- pFM2 %>% group_by(Network) %>% mutate(normZ=value/sum(sqrt(value^2)))

g2 <- ggplot(pFM2,aes(x=Network,y=normZ,fill=motif)) + geom_bar(stat="identity",position=position_dodge()) +
     scale_fill_brewer(palette = "Paired",breaks=c("zAC","zEC","zOM","zTT"),name="Motif\nZ-score",   labels=c("Apparent\ncompetition","Exploitative\ncompetition","Omnivory", "Tri-trophic\nchain")) + 
   xlab("") + ylab("") + theme_bw() + scale_x_discrete(limits=c("Potter Cove","Weddell Sea","Meta-web")) + expand_limits(y=c(0.8,-0.35)) #+ theme(legend.position="bottom")

# Add asteriscs to significative motifs
sig_lbl <- pFM2 %>% mutate(normZ=ifelse(Network=="Potter Cove" & motif=="zAC",normZ+0.05,
                                        ifelse(Network=="Weddell Sea" & (motif=="zTT" | motif=="zOM"),normZ-0.05,NA)))  

g2 <- g2 + geom_text(data = sig_lbl, label = "*",position=position_dodge(width=0.9)) 

g2
require(cowplot)
g3 <- plot_grid(g1,g2,labels = c("A","B"),align = "h",rel_widths=c(.9,1.2))
g3
save_plot("Figures/Motif_Zs_ByNetwork.png",g3,base_width=8,base_height=5,dpi=600)



```

# Topologcal roles with meta-web assembly model 

```{r MetaWebTopologicalRoles, eval=FALSE,echo=F,message=T,warning=T}

# Check the correct meta-web adjacency matrix is loaded

dim(A)==c(859,859)

#
# 500 time steps 
#
tf <- 500
set.seed(1234)

# Weddell Sea 
#
#
m <- 0.084 
a <- 0.076
tf <- 531
AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
dfA$S[tf-200]
plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

g <- graph_from_adjacency_matrix( AA$A, mode  = "directed")

# Select only a connected subgraph graph 
#
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
vcount(g)
modulos<-cluster_spinglass(g)

topoRoles_metaWebAssembly <- calc_avg_topological_roles(g,"Weddell",10)   # 30 simulations are enough to obtain stable topological roles

# Initialize hub_conn
hub_conn_Assembly <- data.frame()

# Plot and clasify topological roles
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(topoRoles_metaWebAssembly,g,modulos) %>% mutate(Network="Weddell"))

plotTopoRolesByTLByMod("","Weddell","",modulos,hub_conn_Assembly,"",g)


# Potter Cove Simulations
#
#

set.seed(123)
m <- 0.023
a <- 0.094
tf <- 546

AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))

plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

AA$S[tf]

g <- graph_from_adjacency_matrix( AA$A*1, mode  = "directed")
# Add Names
#V(g)$label <- rownames(A)

# Select only a connected subgraph graph 
#
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
#plot(g,edge.arrow.size=.4,edge.color="orange", vertex.color="gray50",vertex.size=3,layout=layout_with_fr)
vcount(g)
sum(degree(g,mode="in")==0)
V(g)[degree(g,mode="in")==0]$label

modulos<-cluster_spinglass(g)

tR <- calc_avg_topological_roles(g,"Potter",10)
topoRoles_metaWebAssembly <- bind_rows(topoRoles_metaWebAssembly,tR )


# Plot and clasify topological roles
#
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(tR,g,modulos) %>% mutate(Network="Potter"))

plotTopoRolesByTLByMod("","Potter","",modulos,hub_conn_Assembly,"",g)

save.image()

# Topological Roles proportions test and plot
#
#
names(hub_conn)


tbl <- table(hub_conn$Network,hub_conn$type)

tbl1 <- table(hub_conn_Assembly$Network,hub_conn_Assembly$type)
tbl1 <- rbind(tbl,tbl1) 
tbl1 <- tbl1[c(2,4,5),]
class(tbl1) <- "table"

chisq.test(tbl1,simulate.p.value = TRUE, B=10000)

require(ggplot2)
require(scales)
df1 <- data.frame(tbl1) 
names(df1) <- c("Network","Rol","count")
df1 <- filter(df1,count!=0)
df1 <- df1 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df1$Network <- factor(df1$Network, levels=c("Potter","Weddell","Meta")) 

levels(df1$Network) <- c("Potter Cove\nModel","Weddell Sea\nModel","Meta-web")


gP1 <- ggplot(df1,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")


# Proportion of topo roles of the real networks
#
df2 <- data.frame(tbl,stringsAsFactors = FALSE)
names(df2) <- c("Network","Rol","count")
df2 <- filter(df2,count!=0)
df2 <- df2 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df2$Network <- factor(df2$Network, levels=c("Local","Regional","Meta")) 
levels(df2$Network) <- c("Potter Cove","Weddell Sea","Meta-web")

gP2 <- ggplot(df2,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")

legend_b <- get_legend(gP2 + theme(legend.position="bottom"))

require(cowplot)
gP3 <- plot_grid(gP2,gP1,labels = c("A","B"),align = "h")
gP3 <- plot_grid( gP3, legend_b, ncol = 1, rel_heights = c(1, .05))
save_plot("Figures/PropRoles_ByNetwork_Model.png",gP3,base_width=8,base_height=5,dpi=600)
#ggsave("Figures/PropMotif_Roles_ByNetwork.png",width=8,height=5,units="in",dpi=600)

save.image()
```

