---
title: "From metawebs to regional and local"
author: "L.A.S."
output: html_document
editor_options: 
  chunk_output_type: console
---

## Setup

- **I run the analysis chunk by chunk, not the whole Rmd** 

- So I set `eval=True` or `eval=False` to run a particular chunk or I run it interactively 


```{r setup, echo=FALSE }
load(".RData")

needed_packages <- c(
    "ggplot2"
  , "igraph"
  , "dplyr"
  , "stringr"
  , "devtools")

lapply(needed_packages, function(x) { if(!require(x,character.only = TRUE)){ install.packages(x) }} )

theme_set(theme_bw())

if( require(meweasmo) == FALSE)
  install_github("lsaravia/meweasmo")
if( require(multiweb) == FALSE)
  install_github("lsaravia/multiweb")

source("R/network_fun.r")

```

# Check the steady state of the model   

```{r checkSteadyState, eval=F,echo=F,message=T,warning=T}

source("R/network_fun.r")

#
# Read data and trim species names to avoid duplicates 
#
# dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
# dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))
# 
#
# Select food web 
#
# dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
# redl <- graph_from_edgelist(dtot1, directed  = T)
# Delete cannibalistic 

redl <- meta 
sum(degree(redl,mode="in")==0) == websTbl$Basal[3]

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]

#
# Testing if 500 time steps is enough to find equilibrium point
#
tf <- 2000
m <- rep(0.05,times=dimA)
e <- rep(0.2, times=dimA)
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 

tf <- 1500
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf1 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 

tf <- 1000
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf2 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 

tf <- 500
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf3 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 

#
# Kernel density based global two-sample comparison test 2d 
# to determine if the last 100 time steps have the same distribution of C and S 
# and therefore there is steady state
#
require(ks)
kde.test(AAdf3[,1:2],AAdf[,1:2])$pvalue
# [1] 0.9934058
kde.test(AAdf3[,1:2],AAdf1[,1:2])$pvalue
# [1] 0.7734683
kde.test(AAdf3[,1:2],AAdf2[,1:2])$pvalue
# [1] 0.6778419

AAdf <- bind_rows(AAdf %>% mutate(Sim="2000"), AAdf1 %>% mutate(Sim="1500"), AAdf2 %>% mutate(Sim="1000"), AAdf3 %>% mutate(Sim="500"))
ggplot(AAdf, aes(S,C,color=Sim))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))

#
# Testing if there are difference with different m/e 
#

AAdf <- AAdf %>% mutate(e=0.2)

tf <- 500
m <- rep(0.2,times=dimA)
e <- rep(0.8, times=dimA)
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),Sim="500",e=0.8) )

ggplot(AAdf %>% filter(Sim=="500"), aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))

tf <- 500
m <- rep(0.02,times=dimA)
e <- rep(0.08, times=dimA)
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),Sim="500",e=0.08) )

ggplot(AAdf %>% filter(Sim=="500"), aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))

tf <- 500
m <- rep(0.02,times=dimA)
e <- rep(0.02, times=dimA)
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),Sim="500",e=0.02) )

ggplot(AAdf %>% filter(Sim=="500"), aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))


tf <- 500
m <- rep(0.02,times=dimA)
e <- rep(0.01, times=dimA)
AA <- metaWebNetAssembly(A,m,e,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),Sim="500",e=0.01) )

ggplot(AAdf %>% filter(Sim=="500"), aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC))

```

# Simulate a grid of parameters to select the best options

* One possible modification is to calculate a bivariate confidence ellipse and check if the desired object is inside it 
* A method using the t-bidimensional distribution is here https://github.com/tidyverse/ggplot2/blob/master/R/stat-ellipse.R

```{r makeSimulations100000, eval=TRUE,echo=F,message=T,warning=T}


redl <- meta 
sum(degree(redl,mode="in")==0) == websTbl$Basal[3]

A <- get.adjacency(redl,sparse=F)
dimA <- nrow(A)

# Simulate a grid of parameters to select the best options using latin hypercubic sampling
#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
# require(GenSA)
# https://cran.r-project.org/web/packages/GenSA/GenSA.pdf
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)
# simMetaWebAssembly <- tibble()
# simulations with probability of secondary extinction == 1
# par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
# sim <- sim_metaWebAssembly_lhs(2, 20, par_ranges,A )
# 
# simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
# saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")



# simulations with probability of secondary extinction != 1
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A )

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction == 0
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  50000, par_ranges,A )

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

#simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ))
knitr::kable(simMetaWebAssembly %>% group_by(model) %>% summarise(n=n()))

ggplot(simMetaWebAssembly, aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Connectance,color=Network),size=0.3) + coord_cartesian(ylim=c(0,0.1)) + facet_wrap(~model)

ggplot(simMetaWebAssembly, aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Links,color=Network),size=0.3) + coord_cartesian(ylim=c(0,3000)) + facet_wrap(~model)

ggplot(simMetaWebAssembly %>% mutate(secExt = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") )), aes(S,L,color=secExt))+ geom_point(size=.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Links,color=Network),size=0.4) + coord_cartesian(ylim=c(0,9100)) + scale_color_brewer(palette= "Dark2",name="", labels=c("Fixed Sec.Ext.", "Potter","Meta", "No Sec.Ext.", "Prob. Sec.Ext.","Weddell" ))  


```

## Make the fit finding the parameters with less distance to empirical networks

```{r fitMetaWebPC50002, eval=FALSE,echo=F,message=T,warning=T}


#
# Potter Cove
#
# Use this tolerance = tol to display a more detailed plot 

tol <- .01
sel <- simMetaWebAssembly %>% mutate(alpha=m/a) %>% filter(S>websTbl$Size[1]*(1-tol),S<websTbl$Size[1]*(1+tol), se<0) %>% arrange(S)
#
# One option is to fit using the distance to S and C
#
sel <- sel %>% mutate(distance = sqrt(((websTbl$Size[1] - S)/websTbl$Size[1])^2 + ((websTbl$Connectance[1] - C )/websTbl$Connectance[1])^2), min_dist = (distance == min(distance))) %>% arrange(distance)
sel %>% filter(min_dist)
#
# Other option is to fit using the distance to S and L
#
sel <- sel %>% mutate(distance = sqrt(((websTbl$Size[1] - S)/websTbl$Size[1])^2 + ((websTbl$Links[1] - L )/websTbl$Links[1])^2), min_dist = (distance == min(distance))) %>% arrange(distance)
sel %>% filter(min_dist)

ggplot(sel, aes(S,C, color=min_dist)) + geom_point(alpha=0.5) + theme_bw() + geom_point(data=websTbl %>% filter(Network=="local"), aes(Size,Connectance,color=Network))  
fittedMetaWeb <- bind_rows(fittedMetaWeb, sel %>% filter(min_dist) %>% mutate(Network="Potter",fit_type="S-L se<1"))
# Simulations
#       m     a        S        L         C    alpha
# 4 0.019  0.08 108.0955 249.9427 0.02139875 0.2375
# 7 0.023 0.096 109.0323 247.8472 0.02086496 0.2395833
# 10 0.023 0.094 109.1362 247.9425 0.02079193 0.2446809
#           m         a        S        L         C     alpha    distance min_dist
# 1 0.1085565 0.3033321 93.42574 323.0396 0.0370103 0.3578801 0.007572439     TRUE
# 1 0.07614384 0.2346869 93.17822 324.6337 0.0373908 0.3244487 0.00222325     TRUE  Potter
simMetaWebAssembly %>% transmute(min(m),max(m),min(a),max(a)) %>% distinct()

# Weddell Sea
#
tol <- .2
sel <- simMetaWebAssembly %>% mutate(alpha=m/a) %>% filter(S>websTbl$Size[2]*(1-tol),S<websTbl$Size[2]*(1+tol),se<1) %>% arrange(S)

#
# One option is to fit using the distance to S and C
#
sel <- sel %>% mutate(distance = sqrt(((websTbl$Size[2] - S)/websTbl$Size[2])^2 + ((websTbl$Connectance[2] - C )/websTbl$Connectance[2])^2), min_dist = (distance == min(distance)))
sel %>% filter(min_dist)

#
# Other option is to fit using the distance to S and L
#
sel <- sel %>% mutate(distance = sqrt(((websTbl$Size[2] - S)/websTbl$Size[2])^2 + ((websTbl$Links[2] - L )/websTbl$Links[2])^2), min_dist = (distance == min(distance))) %>% arrange(distance)
sel %>% filter(min_dist)


fittedMetaWeb <- bind_rows(fittedMetaWeb, sel %>% filter(min_dist) %>% mutate(Network="Weddell",fit_type="S-L se<1"))

ggplot(sel, aes(S,C, color=min_dist)) + geom_point(alpha=0.5) + theme_bw() + geom_point(data=websTbl %>% filter(Network=="Regional"), aes(Size,Connectance,color=Network))  
ggplot(sel, aes(S,L, color=min_dist)) + geom_point(alpha=0.5) + theme_bw() + geom_point(data=websTbl %>% filter(Network=="Regional"), aes(Size,Links,color=Network)) + scale_color_discrete(name="",
                         labels=c("Simulations", "Empirical (Weddell)","Fit" ))  

# Simulations
#       m     a        S        L         C    alpha
# 4 0.022 0.021 385.7151 2143.468 0.0144348  1.047619
# 7 0.044 0.041 381.4585 2150.424 0.01477366 1.073171
# 10 0.084 0.076 380.7409 2146.395 0.01480693 1.105263
#           m          a        S        L          C    alpha distance min_dist
# 1 0.1052653 0.09006522 369.3861 2166.782 0.01588013 1.168768   0.2043     TRUE
# 1 0.01695172 0.014541 366.8317 2061.772 0.0153217 1.165787 0.1779407     TRUE
knitr::kable(fittedMetaWeb %>% dplyr::select( Network,  everything(), -min_dist) %>% arrange(Network))

rm(X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ravg)
save.image()

```

# Make simulations with fitted parameters with S-L method

```{r fitMetaWebSims, eval=FALSE,echo=F,message=T,warning=T}

fittedMetaWeb <- fittedMetaWeb %>% arrange(Network,fit_type)
tf <- 500
set.seed(1110)
mm <- rep(fittedMetaWeb$m[3],nrow(A))
aa <- rep(fittedMetaWeb$a[3],nrow(A))
se <- rep(1,nrow(A))
AA <- metaWebNetAssembly(A,mm,aa,se,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
#  98.74418605 325.01993355   0.03333396
#  96.3887043 335.3953488   0.0360998
#  94.51827243 314.86710963   0.03524486
#  93.1661130 295.3023256   0.0340213
#  96.05647841 318.84053156   0.03455574
#  95.39867110 309.66445183   0.03402567
#  96.18272425 314.94352159   0.03404384
#  96.80066445 314.12292359   0.03352301
#  100.98338870 329.87043189   0.03234771
#  115.76079734 364.94352159   0.02723345

# Running averages
ravg <- tibble()
ravg <- bind_rows( ravg, plot_NetAssemblyModel_eqw(AA,50,"Figures/PotterCove_Meta-webSim_avg.png") %>% mutate(Network = "Potter"))

# Time series plot
plot_NetAssemblyModel(AA,300,"Figures/PotterCove_Meta-webSim_ts.png")

tf <- 500
set.seed(1110)
mm <- rep(fittedMetaWeb$m[4],nrow(A))
aa <- rep(fittedMetaWeb$a[4],nrow(A))
se <- rep(fittedMetaWeb$se[4],nrow(A))
AA <- metaWebNetAssembly(A,mm,aa,se,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
ravg <- bind_rows( ravg, plot_NetAssemblyModel_eqw(AA,50,"Figures/PotterCove_Meta-webSim_avg_se.png") %>% mutate(Network = "PotterSe"))
plot_NetAssemblyModel(AA,300,"Figures/PotterCove_Meta-webSim_ts_se.png")

# Weddell 
#
mm <- rep(fittedMetaWeb$m[7],nrow(A))
aa <- rep(fittedMetaWeb$a[7],nrow(A))
se <- rep(fittedMetaWeb$se[7],nrow(A))

AA <- metaWebNetAssembly(A,mm,aa,se,tf)

dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
# [1] 3.505017e+02 2.248110e+03 1.829942e-02
ravg <- bind_rows( ravg, plot_NetAssemblyModel_eqw(AA,50) %>% mutate(Network = "Weddell"))
plot_NetAssemblyModel(AA,300)
plot_NetAssemblyModel_eqw(AA,50,"Figures/Weddell_Meta-webSim_avg.png")
plot_NetAssemblyModel(AA,300,"Figures/Weddell_Meta-webSim_ts.png")

# Weddell 
#
mm <- rep(fittedMetaWeb$m[8],nrow(A))
aa <- rep(fittedMetaWeb$a[8],nrow(A))
se <- rep(fittedMetaWeb$se[8],nrow(A))

AA <- metaWebNetAssembly(A,mm,aa,se,tf)

dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
# [1] 3.505017e+02 2.248110e+03 1.829942e-02
ravg <- bind_rows( ravg, plot_NetAssemblyModel_eqw(AA,50) %>% mutate(Network = "WeddellSe"))
plot_NetAssemblyModel(AA,300)
plot_NetAssemblyModel_eqw(AA,50,"Figures/Weddell_Meta-webSim_avg_se.png")
plot_NetAssemblyModel(AA,300,"Figures/Weddell_Meta-webSim_ts_se.png")




rm(X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,ravg,dfA,dtot,dtot1,cl,sel,redl,e,ee,ext,aa,m,mig,mm,se,colTL,cn,colnet)
save.image()

# Plot of five simulations 
#
gg <- plot_NetAssemblyModel(AA,100)

# Plot of S and C for Weddell 
#
require(cowplot)
g3 <- plot_grid(gg[[1]],gg[[3]],labels = c("A","B"),align = "h")
save_plot("Figures/Weddell_Meta-webSim_SC.png",g3,base_width=8,base_height=5,dpi=300)


```



# Local web (Potter Cove) compared to  metaWeb assembly model

```{r PotterGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Read data and trim species names to avoid duplicates 
#
# dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
# dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))
# 
# #
# # Select meta web 
# #
# dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
# redl <- graph_from_edgelist(dtot1, directed  = T)
# # Delete cannibalistic 
# redl <- simplify(redl)
# sum(degree(redl,mode="in")==0)
# 
redl <- meta 
sum(degree(redl,mode="in")==0) == websTbl$Basal[3]

A <- get.adjacency(redl,sparse=F)
dim(A)                             

#
# Select Local food web 
# 
redl <- pott 
sum(degree(redl,mode="in")==0) == websTbl$Basal[1]

# dtot1 <- as.matrix(dtot %>% filter(Network=="Local") %>% dplyr::select(Prey_name,Predator_name))
# redl <- graph_from_edgelist(dtot1, directed  = T)

#
# Calculate Trophic Position
#
require(NetIndices)
TL <-TrophInd(get.adjacency(redl,sparse=F),Dead=c("Fresh detritus","Aged detritus","Necromass"))

#
# Compare modularity 
#
require(tictoc)
fittedMetaWeb$m[1]
fittedMetaWeb$a[1]

tic()
tbl <- calc_modularity_metaWebAssembly(redl, A, fittedMetaWeb$m[1],fittedMetaWeb$a[1],1000,TL)
toc()
sim <- tbl$sim
tblMdlWeb <- tbl$su %>% mutate(Network="Potter") %>% inner_join(dplyr::select(websTbl,Size:Modularity), by="Network")

#
# Calculate z-score of modularity
#
tblMdlWeb <- tblMdlWeb %>% mutate(zMO= (Modularity- mdlMO)/MOsd, zGR=(Groups-mdlGR)/(GRhigh-GRlow)*2)

websAssemblyModel <- dplyr::select(tblMdlWeb,Network:Modularity,mdlCC:zTI,zMO:zGR)

#
# Correct the calculation of z-score
#
websAssemblyModel$mdlMO[2] <- with(tblMdlWeb,mdlMO)
websAssemblyModel$zMO[2] <- with(tblMdlWeb, (Modularity- mdlMO)/MOsd)
rm(tbl)

websAssemblyModelSim <-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network="Potter"))  
save.image()



```



# Regional web (Weddell) compared to  metaWeb assembly model 

```{r WeddellGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Select "Regional" food web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Regional") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
redl <- simplify(redl)


require(NetIndices)
TL<-TrophInd(get.adjacency(redl,sparse=F),Dead=c("Detritus","Necromass"))

#
# Compare modularity 
#
require(tictoc)
m <- 0.084 
a <- 0.076
tic()
tbl <- calc_modularity_metaWebAssembly(redl, A, m,a,1000,TL)
toc()
sim <- tbl$sim

tblMdlWeb <- tbl$su %>% mutate(Network="Weddell") %>% inner_join(dplyr::select(websTbl,Size:Modularity), by="Network")

#
# Calculate z-score of modularity
#
tblMdlWeb <- tblMdlWeb %>% mutate(zMO= (Modularity- mdlMO)/MOsd, zGR=(Groups-mdlGR)/(GRhigh-GRlow)*2)

websAssemblyModel <- bind_rows(websAssemblyModel, dplyr::select(tblMdlWeb,Network:Modularity,mdlCC:zTI,zMO:zGR))

#
# Correct the calculation of z-score
#
# websAssemblyModel$mdlMO[1] <- with(tblMdlWeb,mdlMO)
# websAssemblyModel$zMO[1] <- with(tblMdlWeb, (Modularity- mdlMO)/MOsd)
websAssemblyModelSim <-  sim %>% mutate(Network="Weddell")


#
# Plots of the distribution of simulated indices
#
require(RColorBrewer)
col <- brewer.pal(8,"Dark2")
col <- c("#0097A7","#448AFF","#212121")
dat <- websAssemblyModel %>% filter(Network=="Regional") %>% rename(modularity=Modularity) %>% bind_cols(websTbl %>% filter(Network=="Weddell") %>% select(Q,mTI))

sim <- websAssemblyModelSim %>% filter(Network=="Weddell")
names(dat)
names(sim)
#
# Plot for the figure 1 
#
p <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_classic() + xlab("Network metric")
p + geom_segment(data=dat,aes(x=Q+0.4,xend=Q+0.4, y=30, yend = 0), colour=col[2], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[3], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[3], size=1, linetype=1 )


p1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=SWness, y=85, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=55, yend = 0), colour=col[2], size=1, linetype=1 )


p2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=Q, y=30, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[2], size=1, linetype=1 )

p3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=mTI, y=25, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=18, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=18, yend = 0), colour=col[2], size=1, linetype=1 )


p4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
    geom_segment(data=dat,aes(xend=modularity, y=25, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=18, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=18, yend = 0), colour=col[2], size=1, linetype=1 )


dat <- websAssemblyModel %>% filter(Network=="Local") %>% rename(modularity=Modularity) %>% bind_cols(websTbl %>% filter(Network=="Potter") %>% select(Q,mTI))

sim <- websAssemblyModelSim %>% filter(Network=="Potter")

q1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=SWness, y=185, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=120, yend = 0), colour=col[2], size=1, linetype=1 )


q2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=Q, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )

q3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
    geom_segment(data=dat,aes(xend=mTI, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )


q4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
    geom_segment(data=dat,aes(xend=modularity, y=24, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
    geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=16, yend = 0), colour=col[2], size=1, linetype=1 ) +
    geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=16, yend = 0), colour=col[2], size=1, linetype=1 )


require(cowplot)
p5 <- plot_grid(q1+xlab(""),q2+ylab("")+xlab(""),q3+ylab("")+xlab(""),q4+ylab("")+xlab(""),
                p1,p2+ylab(""),p3+ylab(""),p4+ylab(""),align = "h",nrow=2,labels = c("A","","","","B"))
save_plot("Figures/globProp_assembly_ByNetwork.png",p5,base_width=8,base_height=5,dpi=600)



save.image()
```


# Motif Potter Cove compared to  metaWeb assembly model 

```{r PotterMotifMetaWebAssembly, eval=F,echo=F,message=T,warning=T}


#sourceCpp("src/NetAssemblyFromMetaWeb.cpp")

#
# Read data and trim species names to avoid duplicates 
#
dtot <- read.delim("Data/Foodwebs.dat", quote="",stringsAsFactors = F)
dtot <- dtot %>% mutate(Predator_name=str_trim(Predator_name), Prey_name=str_trim(Prey_name))

#
# Select meta web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Meta") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
# Delete cannibalistic 
redl <- simplify(redl)
sum(degree(redl,mode="in")==0)

A <- get.adjacency(redl,sparse=F)
dim(A)                             

#
# Select Local food web 
# 

dtot1 <- as.matrix(dtot %>% filter(Network=="Local") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)

#
# Motif
#
mot <- triad_census(redl)

mot[4] # Exploitative competition
mot[5] # Apparent competition
mot[6] # Tri-trophic chain
mot[9] # Omnivory

#FreqMotif <- data.frame(Network="Local",t(mot))

set.seed(123)
m <- 0.023
a <- 0.094
motif_metaWeb <- calc_motif_metaWebAssembly(redl, A, m,a,1000)

motif_metaWeb <- motif_metaWeb %>% mutate(Network="Local")


save.image()

```


# Motif Weddell compared to  metaWeb assembly model 

```{r WeddellMotifMetaWebAssembly, eval=FALSE,echo=F,message=T,warning=T}


#
# Select "Regional" food web 
#
dtot1 <- as.matrix(dtot %>% filter(Network=="Regional") %>% dplyr::select(Prey_name,Predator_name))
redl <- graph_from_edgelist(dtot1, directed  = T)
redl <- simplify(redl)


#
# Motif
#
set.seed(123)

m <- 0.084 
a <- 0.076
m_metaWeb <- calc_motif_metaWebAssembly(redl, A, m,a,1000)

motif_metaWeb <- bind_rows(motif_metaWeb, m_metaWeb %>% mutate(Network="Regional"))

rm(m_metaWeb)
save.image()


select(motif_metaWeb, explComp,EClow,EChigh)
select(motif_metaWeb, apprComp,AClow,AChigh,zAC)
select(motif_metaWeb, triTroph,TTlow,TThigh,zTT)
select(motif_metaWeb, omnivory,OMlow,OMhigh,zOM)

# Generate tables for the manuscript
#
#
require(pander)
panderOptions('table.split.table',Inf)
panderOptions('table.style', 'multiline')

webs_tmp <- inner_join(websAssemblyModel,dplyr::select(websTbl,Q,mTI,Network), by="Network")

pandoc.table(t(webs_tmp %>% dplyr::select(Network,SWness,SWnessCI,zQ,zTI,zMO,zGR,mTI) %>% mutate_if(is.numeric, round, digits=4)))


pandoc.table(t(webs_tmp %>% dplyr::select(Network,Q,Qlow,Qhigh,mTI,TIlow,TIhigh,Modularity, MOlow,MOhigh) %>% mutate_if(is.numeric, round, digits=4)))

pandoc.table(t(motif_metaWeb %>% rename(EC=explComp,AC=apprComp,TT=triTroph,OM=omnivory) %>%
                 dplyr::select(Network,EC,EClow,EChigh,zEC,AC,AClow,AChigh,zAC,TT,TTlow,TThigh,zTT,OM,OMlow,OMhigh,zOM) %>% mutate_if(is.numeric, round, digits=2)))


# Plot of random z-score motif normalized
#
#

require(tidyr)
names(motif)
pFM1 <- motif %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,value,zEC:zOM) %>% mutate(type="Random z-score")
pFM1$Network <- factor(pFM1$Network)
levels(pFM1$Network) <- c("Potter Cove","Meta-web","Weddell Sea")

# Normalize z-scores
#
pFM1 <- pFM1 %>% group_by(Network) %>% mutate(normZ=value/sum(sqrt(value^2)))
g1 <- ggplot(pFM1,aes(x=Network,y=normZ,fill=motif)) + geom_bar(stat="identity",position=position_dodge()) +
   scale_fill_brewer(palette = "Paired",breaks=c("zAC","zEC","zOM","zTT"),name="Motif\nZ-score",   labels=c("Apparent\ncompetition","Exploitative\ncompetition","Omnivory", "Tri-trophic\nchain")) + guides(fill=FALSE) +
   xlab("") + ylab("") + theme_bw() + scale_x_discrete(limits=c("Potter Cove","Weddell Sea","Meta-web")) + expand_limits(y=c(0.8,-0.35)) #+ theme(legend.position="bottom")

# Add asteriscs to significative motifs

sig_lbl <- pFM1 %>% mutate(normZ=ifelse(motif=="zTT", normZ-0.05,normZ+0.05) )
g1 <- g1 + geom_text(data = sig_lbl, label = "*",position=position_dodge(width=0.9))

# Plot of assembly motifs normalized 
#
names(motif_metaWeb)
pFM2 <- motif_metaWeb %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,value,zEC:zOM) %>% mutate(type="Assembly z-score", Network=factor(Network))

levels(pFM2$Network) <- c("Potter Cove","Weddell Sea")

pFM2 <- pFM2 %>% group_by(Network) %>% mutate(normZ=value/sum(sqrt(value^2)))

g2 <- ggplot(pFM2,aes(x=Network,y=normZ,fill=motif)) + geom_bar(stat="identity",position=position_dodge()) +
     scale_fill_brewer(palette = "Paired",breaks=c("zAC","zEC","zOM","zTT"),name="Motif\nZ-score",   labels=c("Apparent\ncompetition","Exploitative\ncompetition","Omnivory", "Tri-trophic\nchain")) + 
   xlab("") + ylab("") + theme_bw() + scale_x_discrete(limits=c("Potter Cove","Weddell Sea","Meta-web")) + expand_limits(y=c(0.8,-0.35)) #+ theme(legend.position="bottom")

# Add asteriscs to significative motifs
sig_lbl <- pFM2 %>% mutate(normZ=ifelse(Network=="Potter Cove" & motif=="zAC",normZ+0.05,
                                        ifelse(Network=="Weddell Sea" & (motif=="zTT" | motif=="zOM"),normZ-0.05,NA)))  

g2 <- g2 + geom_text(data = sig_lbl, label = "*",position=position_dodge(width=0.9)) 

g2
require(cowplot)
g3 <- plot_grid(g1,g2,labels = c("A","B"),align = "h",rel_widths=c(.9,1.2))
g3
save_plot("Figures/Motif_Zs_ByNetwork.png",g3,base_width=8,base_height=5,dpi=600)



```

# Topologcal roles with meta-web assembly model 

```{r MetaWebTopologicalRoles, eval=FALSE,echo=F,message=T,warning=T}

# Check the correct meta-web adjacency matrix is loaded

dim(A)==c(859,859)

#
# 500 time steps 
#
tf <- 500
set.seed(1234)

# Weddell Sea 
#
#
m <- 0.084 
a <- 0.076
tf <- 531
AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))
dfA$S[tf-200]
plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

g <- graph_from_adjacency_matrix( AA$A, mode  = "directed")

# Select only a connected subgraph graph 
#
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
vcount(g)
modulos<-cluster_spinglass(g)

topoRoles_metaWebAssembly <- calc_avg_topological_roles(g,"Weddell",10)   # 30 simulations are enough to obtain stable topological roles

# Initialize hub_conn
hub_conn_Assembly <- data.frame()

# Plot and clasify topological roles
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(topoRoles_metaWebAssembly,g,modulos) %>% mutate(Network="Weddell"))

plotTopoRolesByTLByMod("","Weddell","",modulos,hub_conn_Assembly,"",g)


# Potter Cove Simulations
#
#

set.seed(123)
m <- 0.023
a <- 0.094
tf <- 546

AA <- metaWebNetAssembly(A,m,1,a,tf)
dfA <- data.frame(S=AA$S[200:tf],L=as.numeric(AA$L[200:tf]),T=c(200:tf))
c(mean(dfA$S),mean(dfA$L),mean(dfA$L)/(mean(dfA$S)*mean(dfA$S)))

plot_NetAssemblyModel_eqw(AA,100)
plot_NetAssemblyModel(AA,300)

AA$S[tf]

g <- graph_from_adjacency_matrix( AA$A*1, mode  = "directed")
# Add Names
#V(g)$label <- rownames(A)

# Select only a connected subgraph graph 
#
dg <- components(g)
g <- induced_subgraph(g, which(dg$membership == which.max(dg$csize)))
#plot(g,edge.arrow.size=.4,edge.color="orange", vertex.color="gray50",vertex.size=3,layout=layout_with_fr)
vcount(g)
sum(degree(g,mode="in")==0)
V(g)[degree(g,mode="in")==0]$label

modulos<-cluster_spinglass(g)

tR <- calc_avg_topological_roles(g,"Potter",10)
topoRoles_metaWebAssembly <- bind_rows(topoRoles_metaWebAssembly,tR )


# Plot and clasify topological roles
#
hub_conn_Assembly <- bind_rows(hub_conn_Assembly, 
                               plot_topological_roles(tR,g,modulos) %>% mutate(Network="Potter"))

plotTopoRolesByTLByMod("","Potter","",modulos,hub_conn_Assembly,"",g)

save.image()

# Topological Roles proportions test and plot
#
#
names(hub_conn)


tbl <- table(hub_conn$Network,hub_conn$type)

tbl1 <- table(hub_conn_Assembly$Network,hub_conn_Assembly$type)
tbl1 <- rbind(tbl,tbl1) 
tbl1 <- tbl1[c(2,4,5),]
class(tbl1) <- "table"

chisq.test(tbl1,simulate.p.value = TRUE, B=10000)

require(ggplot2)
require(scales)
df1 <- data.frame(tbl1) 
names(df1) <- c("Network","Rol","count")
df1 <- filter(df1,count!=0)
df1 <- df1 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df1$Network <- factor(df1$Network, levels=c("Potter","Weddell","Meta")) 

levels(df1$Network) <- c("Potter Cove\nModel","Weddell Sea\nModel","Meta-web")


gP1 <- ggplot(df1,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")


# Proportion of topo roles of the real networks
#
df2 <- data.frame(tbl,stringsAsFactors = FALSE)
names(df2) <- c("Network","Rol","count")
df2 <- filter(df2,count!=0)
df2 <- df2 %>% group_by(Network) %>% mutate(total=sum(count),Freq=count/total)
df2$Network <- factor(df2$Network, levels=c("Local","Regional","Meta")) 
levels(df2$Network) <- c("Potter Cove","Weddell Sea","Meta-web")

gP2 <- ggplot(df2,aes(x=Network,y=Freq,fill=Rol)) + geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + theme(legend.position="none")

legend_b <- get_legend(gP2 + theme(legend.position="bottom"))

require(cowplot)
gP3 <- plot_grid(gP2,gP1,labels = c("A","B"),align = "h")
gP3 <- plot_grid( gP3, legend_b, ncol = 1, rel_heights = c(1, .05))
save_plot("Figures/PropRoles_ByNetwork_Model.png",gP3,base_width=8,base_height=5,dpi=600)
#ggsave("Figures/PropMotif_Roles_ByNetwork.png",width=8,height=5,units="in",dpi=600)

save.image()
```

