---
title: "From metawebs to regional and local"
author: "L.A.S."
output: html_document
editor_options: 
  chunk_output_type: console
---

## Setup

- I run the analysis setting `eval=True` or `eval=False` to run a particular chunk, not the whole Rmd. 

- To run the simulations for each metaweb fit, I first read the dataset, turning on the corresponding chunk, and I run the fitting procedure turning on that chunk.  

```{r setup, echo=FALSE }
if(file.exists(".RData")) load(".RData")

needed_packages <- c(
    "ggplot2"
  , "igraph"
  , "dplyr"
  , "stringr"
  , "devtools"
  , "ks")

lapply(needed_packages, function(x) { if(!require(x,character.only = TRUE)){ install.packages(x) }} )

theme_set(theme_bw())

if( require(meweasmo) == FALSE)
  install_github("lsaravia/meweasmo")
if( require(multiweb) == FALSE)
  install_github("lsaravia/multiweb")

source("R/network_fun.r")

```

# Read Antarctic Networks

```{r readAntarctic, eval=FALSE,echo=F,message=T,warning=T}
#
# Read the Antarctic Metawebs files with New Weddell from @Brose2019 (GATEWAy database)
#
dn <- list.files("Data",pattern = "^[MWP].*\\.dat$")
dn <- paste0("Data/", dn)
dn <- dn[c(2,3,1)]
ig_list <- readNetwork(dn,edgeListFormat=2)
names(ig_list) <- c("Ant_Potter","Ant_Weddell","Ant_Meta")

redl <- ig_list[["Ant_Meta"]]
sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network=="Ant_Meta") %>% dplyr::select(Basal)

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]
#
# Add Meta web variable to use in simulations
#
Ant_Meta <- redl
```


## Read the Islands data set 

```{r readIslands, eval=FALSE,echo=TRUE,message=FALSE }

#
# Extract Weddell Sea from GATEWAy database
#
ga <- readr::read_csv("~/Dropbox/Projects/MetaWebsAssembly/Data/283_2_FoodWebDataBase_2018_12_10.csv",col_types = "icccccccccccccddddddccccccccddddddcddccddciicc")

fw_name <- ga %>% filter(grepl("Piechnik",link.citation )) %>% distinct(foodweb.name)                
Have_df <- ga %>% filter(grepl("Piechnik",link.citation )) %>% dplyr::select(con.taxonomy,con.taxonomy.level,res.taxonomy,res.taxonomy,foodweb.name)
require(igraph)
dtot1 <- as.matrix(Have_df %>% dplyr::select(res.taxonomy,con.taxonomy))
have1  <- graph_from_edgelist(dtot1, directed  = T)

df_list <- Have_df %>% group_split(foodweb.name)
ig_list <- lapply(df_list, function(fw) {
  d1 <- as.matrix(fw %>% dplyr::select(res.taxonomy,con.taxonomy))
  graph_from_edgelist(d1, directed  = T)
})
names(ig_list) <- paste0("Isl_",fw_name$foodweb.name)
ig_list <- c(ig_list, list(Isl_Meta=have1))

redl <- ig_list[["Isl_Meta"]] 

stopifnot(sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network=="Isl_Meta") %>% dplyr::select(Basal))

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]
#
# Add Meta web variable to use in simulations
#
Isl_Meta <- redl


```

# Read the Lakes dataset 

```{r readLakes, eval=FALSE,echo=TRUE,message=FALSE }

require(tidyverse)

#
# Extract Weddell Sea from GATEWAy database
#
ga <- readr::read_csv("~/Dropbox/Projects/MetaWebsAssembly/Data/283_2_FoodWebDataBase_2018_12_10.csv",col_types = "icccccccccccccddddddccccccccddddddcddccddciicc")

fw_name <- ga %>% filter(grepl("Havens",link.citation )) %>% distinct(foodweb.name)                
Have_df <- ga %>% filter(grepl("Havens",link.citation )) %>% dplyr::select(con.taxonomy,con.taxonomy.level,res.taxonomy,res.taxonomy,foodweb.name)
require(igraph)
dtot1 <- as.matrix(Have_df %>% dplyr::select(res.taxonomy,con.taxonomy))
have1  <- graph_from_edgelist(dtot1, directed  = T)

df_list <- Have_df %>% group_split(foodweb.name)
ig_list <- lapply(df_list, function(fw) {
  d1 <- as.matrix(fw %>% dplyr::select(res.taxonomy,con.taxonomy))
  graph_from_edgelist(d1, directed  = T)
})

names(ig_list) <- paste0("Lak_",str_replace_all(fw_name$foodweb.name," ","_"))
ig_list <- c(ig_list, list(Lak_Meta=have1))

redl <- ig_list[["Lak_Meta"]] 

stopifnot(sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network=="Lak_Meta") %>% dplyr::select(Basal))

A <- get.adjacency(redl,sparse=F)
dimA <- dim(A)[1]
#
# Add Meta web variable to use in simulations
#
Lak_Meta <- redl

```

# Check the steady state of the model    

```{r checkSteadyState, eval=F,echo=F,message=T,warning=T}


set.seed(2312)
#
# Testing if 500 time steps is enough to find equilibrium point
#
#
# Testing for the CT model
#
tf <- 3000
m <- rep(0.2,times=dimA)
e <- rep(0.5, times=dimA)
se <- rep(0.7, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP <- plot_NetAssemblyModel_eqw(AA,50)
AAdf <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 1500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
AAdf1 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 1000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP1 <- plot_NetAssemblyModel_eqw(AA,50)
AAdf2 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
tf <- 500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf3 <- tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S)) 
#
# First 100 time steps
#
AAdf4 <- tibble(C=AA$L[2:100]/ (AA$S[2:100])^2 ,S=AA$S[2:100]) %>% mutate(mC = mean(C), mS=mean(S)) 


#
# Kernel density based global two-sample comparison test 2d 
# to determine if the last 100 time steps have the same distribution of C and S 
# and therefore there is steady state
#

require(ks)
kde.test(AAdf3[,1:2],AAdf[,1:2])$pvalue # 500 vs 3000
# [1] 0.2279634
kde.test(AAdf3[,1:2],AAdf1[,1:2])$pvalue # 500 vs 1500
# [1] 0.2766678
kde.test(AAdf3[,1:2],AAdf2[,1:2])$pvalue # 500 vs 1000
# [1] 0.215098

# Testing the first 100 time steps against the last 100 of the '500' simulation
kde.test(AAdf4[,1:2],AAdf3[,1:2])$pvalue
# [1] 0.0708442

# Lakes Islands & Antarctic Metawebs
# There are no differences between 500 and 1000, 500-1500, 500-3000, so we use 1000 time steps
# There are also no differences between the first 100 time steps and the last 100 for the 500 simulation


AAdfTot <- tibble()
AAdfTot <- bind_rows(AAdfTot, 
                     bind_rows(AAdf %>% mutate(Sim="2000"), AAdf1 %>% mutate(Sim="1500"), AAdf2 %>% mutate(Sim="1000"), AAdf3 %>% mutate(Sim="500")) %>% mutate(model_type="Potter", )
                     )
ggplot(AAdfTot, aes(S,C,color=Sim))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)

#
# Changing parameters (Near Weddell)
#
#
# Testing if 500 time steps is enough to find equilibrium point
#
set.seed(2312)

t_window <-  100
tf <- 3000
m <- rep(0.03,times=dimA)
e <- rep(0.016, times=dimA)
se <- rep(0.10, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP2 <- plot_NetAssemblyModel_eqw(AA,50)
AAdf <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 


tf <- 1500
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf1 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 

tf <- 1000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
gP3 <- plot_NetAssemblyModel_eqw(AA,50)

AAdf2 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 


tf <- 5000
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf4 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 

tf <- 500
t_window <- 100
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,50)
AAdf3 <- tibble(C=AA$L[(tf-t_window):tf]/ (AA$S[(tf-t_window):tf])^2 ,S=AA$S[(tf-t_window):tf]) %>% mutate(mC = mean(C), mS=mean(S), Sim=tf) 
AAdf5 <- tibble(C=AA$L[2:100]/ (AA$S[2:100])^2 ,S=AA$S[2:100]) %>% mutate(mC = mean(C), mS=mean(S)) 


#
# Kernel density based global two-sample comparison test 2d 
# to determine if the last 100 time steps have the same distribution of C and S 
# and therefore there is steady state
#
require(ks)
kde.test(AAdf3[,1:2],AAdf[,1:2])$pvalue # 500 vs 3000
# 3.756337e-09

kde.test(AAdf3[,1:2],AAdf1[,1:2])$pvalue # 500 vs 1500
# 2.434068e-05
kde.test(AAdf3[,1:2],AAdf2[,1:2])$pvalue # 500 vs 1000
# 2.890921e-21
#
kde.test(AAdf3[,1:2],AAdf5[,1:2])$pvalue # last 500 vs first 500
# 3.390605e-05

# Lakes, Islands & Antarctic Metaweb
#
# In All cases there are differences p<0.05 due to the quasi-cyclic dynamics

AAdf <- bind_rows(AAdf , AAdf1, AAdf2, AAdf3,AAdf4) %>% mutate(model_type="Weddell",Sim=as.character(Sim))
AAdfTot <- bind_rows(AAdfTot,AAdf)
ggplot(AAdfTot , aes(S,C,color=factor(Sim)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)

#  + theme(axis.text.x=element_blank(),axis.title.x=element_blank())
require(cowplot)
gP5 <- plot_grid(gP$g1,
                 gP$g2,
                 gP1$g1 ,
                 gP1$g2 ,
                 align = "hv",
                  ncol = 2, labels = c('A', '','B'))
save_plot("Figures/Metaweb_steady_state_Potter.png",gP5,base_width=6,base_height=6,dpi=600)

gP5 <- plot_grid(gP2$g1 ,
                 gP2$g2 ,
                 gP3$g1 ,
                 gP3$g2 ,
                 align = "hv",
                  ncol = 2, labels = c('A', '','B'))

save_plot("Figures/Metaweb_steady_state_Weddell.png",gP5,base_width=6,base_height=6,dpi=600)


#ggsave("Figures/Metaweb_SteadyState_byModel.png",width=8,height=5,units="in",dpi=600)

```


# Checking differences with m and a parameters, to know if we can use lambda=m/a as a unique parameter (not include in the paper)

```{r checklambda, eval=F,echo=F,message=T,warning=T}



#
# Testing if there are difference with different m/e 
#      m      a     S     L      C    se model     model_type alpha distance min_dist
# 0.0263 0.106   92.1  324. 0.0383 0.691 Prob      Continuous 0.247  0.00339 TRUE    
# 0.0145 0.0522  91.4  322. 0.0385 0.254 Prob      NA         0.278  0.00786 TRUE    

AAdf <- tibble()
set.seed(2312)

tf <- 1000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=0.25,model_type="Discrete") )


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),se=0.25,e=0.05,model_type="Discrete") )

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~ model_type)


# 
# Continous time 0.0263 0.106   92.1  324. 0.0383 0.691
#
tf <- 1000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),se=0.25,e=0.005,model_type="Continuous"))


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0.25, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),se=0.25,e=0.05,model_type="Continuous"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( ~model_type)


#
# se = 1 
#
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=1,model_type="Discrete")) 


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=1,model_type="Discrete"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( se ~ model_type)


# 
# Continous time 0.0263 0.106   92.1  324. 0.0383 0.691
#
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=1,model_type="Continuous"))


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(1, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=1,model_type="Continuous"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) +
  facet_grid( se ~ model_type)

#
# se = 0 
#
tf <- 1000
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=0,model_type="Discrete")) 


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssembly(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=0,model_type="Discrete"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) + facet_wrap( se ~ model_type)


# 
# Continous time 0.0263 0.106   92.1  324. 0.0383 0.691
#
m <- rep(0.015,times=dimA)
e <- rep(0.005, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.005,se=0,model_type="Continuous"))


m <- rep(0.15,times=dimA)
e <- rep(0.05, times=dimA)
se <- rep(0, times=dimA)
AA <- metaWebNetAssemblyCT(A,m,e,se,tf)
plot_NetAssemblyModel_eqw(AA,100)
AAdf <- bind_rows( AAdf, tibble(C=AA$L[(tf-100):tf]/ (AA$S[(tf-100):tf])^2 ,S=AA$S[(tf-100):tf]) %>% mutate(mC = mean(C), mS=mean(S),e=0.05,se=0,model_type="Continuous"))

ggplot(AAdf, aes(S,C,color=factor(e)))+ geom_point() + theme_bw() + stat_ellipse() + geom_point( aes(mS,mC)) +
  facet_grid( se ~ model_type)


ggsave("Figures/Metaweb_SecExtc_byModel.png",width=8,height=5,units="in",dpi=600)

```

* There are differences if we keep  lambda=m/e fixed and vary e and m, so we use e and m instead of alpha 

* The discrete time and continuous time models give the similar results, this is a verification that the models are well implemented and that the timings of events have no influence on the results. So we use the continuous model (randomized order of events).  

# Antarctic Metaweb Simulate a grid of parameters to select the best options


```{r makeSimulations150000tf1000, eval=FALSE,echo=F,message=T,warning=T}

simMetaWebAssembly <- tibble()

# simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")
# simMetaWebAssembly <- simMetaWebAssembly %>% filter(Metaweb!="Ant") 
# simMetaWebAssembly %>% count(Metaweb,model_type,model)


#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
#
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)

# simulations with probability of secondary extinction == 1
#
# Continuous time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2, 150000, par_ranges,A, 1 ) %>% mutate(model_type="Continuous",Metaweb="Ant")

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction != 1
#
# Continuous time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A, 1) %>% mutate(model_type="Continuous",Metaweb="Ant")

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")


# simulations with probability of secondary extinction == 0
#
# Continuous time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  150000, par_ranges,A,1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# Set the type of models according to probability of secondary extinction
#
# simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ))
knitr::kable(simMetaWebAssembly %>% group_by(model,model_type) %>% summarise(n=n()))

p1 <- ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Connectance,color=Network),size=0.5) + 
  coord_cartesian(ylim=c(0.01,0.1)) +  
  facet_wrap(~ model) + scale_color_brewer(palette= "Paired", guide=FALSE)

ggplot(simMetaWebAssembly, aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl, aes(Size,Links,color=Network),size=0.3) + coord_cartesian(ylim=c(0,3000)) + facet_wrap(~model)

ggplot(simMetaWebAssembly %>% filter(model=="Prob"), aes(S,C,color=model_type))+ geom_point(size=.1,alpha=0.5) + theme_bw() + geom_point(data=websTbl, aes(Size,Connectance,color=Network),size=0.4) + coord_cartesian(ylim=c(0,0.1)) + scale_color_brewer(palette= "Dark2",name="")#, labels=c("Fixed Sec.Ext.", "Potter","Meta", "No Sec.Ext.", "Prob. Sec.Ext.","Weddell" ))  
rm(sim,par_ranges,AAdf,AAdf1,AAdf2,AAdf3,AAdf4,AAdfTot,f)
save.image()
```


## Make the fit finding the parameters with less distance to empirical networks

```{r fitMetaWebPC50002, eval=FALSE,echo=F,message=T,warning=T}


#
# Potter Cove
#
fittedMetaWeb <- bind_rows(fittedMetaWeb, fit_metaWebAssembly_model(websTbl, "Ant_Potter", simMetaWebAssembly))
fittedMetaWeb <- bind_rows(fittedMetaWeb, fit_metaWebAssembly_model(websTbl, "Ant_Weddell", simMetaWebAssembly))


knitr::kable(fittedMetaWeb %>% dplyr::select( Network,  everything(), -min_dist) %>% arrange(Network))

rm(X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ravg,sel,redl,ig_list,web,fmw)
save.image()

```


* Fit of Antarctic Metaweb model using C and S

|Network                 |         m|         a|        se|         S|          L|         C|model_type |Metaweb |model     |       alpha|  distance|fit_type |
|:-----------------------|---------:|---------:|---------:|---------:|----------:|---------:|:----------|:-------|:---------|-----------:|---------:|:--------|
|Ant_Potter              | 0.0188385| 0.0552144| 0.7648036|  93.50495|  346.07921| 0.0395828|Continuous |Ant     |Prob      |   0.3411878| 0.0349252|S-C      |
|Ant_Weddell             | 0.0270526| 0.0163861| 0.1015863| 450.36634| 2312.54455| 0.0114014|Continuous |Ant     |Prob      |   1.6509488| 0.0973483|S-C      |



# Islands Metaweb Simulate a grid of parameters to select the best options


```{r IslandSimulations150000tf1000, eval=FALSE,echo=F,message=T,warning=T}

metaweb_name <-  "Isl_Meta"

# Check redl is the metaweb
# 
stopifnot(  sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network==metaweb_name) %>% select(Basal) )

metaweb_name <- str_sub(metaweb_name,1,3)

A <- get.adjacency(redl,sparse=F)
dimA <- nrow(A)

# Simulate a grid of parameters to select the best options using latin hypercubic sampling
#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
#
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)

# simulations with probability of secondary extinction == 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2, 150000, par_ranges,A, 1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction != 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A, 1) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")


# simulations with probability of secondary extinction == 0
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  150000, par_ranges,A,1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# Set the type of models according to probability of secondary extinction
#
#simMetaWebAssembly <- bind_rows(simMetaWebAssembly, readRDS("Data/simulations_metaWebAssembly.rds"))
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ))
knitr::kable(simMetaWebAssembly %>% group_by(Metaweb,model,model_type) %>% summarise(n=n()))

p2 <- ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Connectance,color=Network),size=0.5) + 
  coord_cartesian(ylim=c(0.05,.5)) + 
  facet_wrap(~ model) + scale_color_brewer(palette= "Paired",guide=FALSE)

ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Links,color=Network),size=0.3) + 
  coord_cartesian(ylim=c(0,3000)) + 
  facet_wrap(~model)  + scale_color_brewer(palette= "Dark2")

# ggsave("Figures/Metaweb_Continuous_Discrete.pdf",width=8,height=5,units="in",dpi=600)
```

## Make the fit Islands

```{r fitMetaWebIslands, eval=FALSE,echo=F,message=T,warning=T}
#
#
# Use this tolerance = tol to display a more detailed plot 

netnames <- names(ig_list)
netnames <- netnames[ netnames != "Isl_Meta" ] 
fmw <-  lapply(netnames, function(n){

  fit_metaWebAssembly_model(websTbl, n, simMetaWebAssembly)
})

fittedMetaWeb <- bind_rows(fittedMetaWeb, fmw)

## Perform ABC and GOF
#
# fmw <-  lapply(netnames, function(n){
# 
#   CI_metaWebAssembly_model(websTbl, n, simMetaWebAssembly)
# })
# fittedMetaWeb_gof <- bind_rows(fittedMetaWeb_gof,fmw)

knitr::kable(fittedMetaWeb %>% filter(model=="Prob") %>% dplyr::select( Metaweb,Network,  everything(), -min_dist, -model_type,-fit_type,-model) %>% arrange(Network), digits = 4)

rm(netnames,fmw,X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ravg,sel,redl,ig_list,web)
save.image()

```


# Lakes Metaweb Simulate a grid of parameters to select the best options


```{r LakesSimulations150000tf1000, eval=FALSE,echo=F,message=T,warning=T}

metaweb_name <-  "Lak_Meta"

# Check redl is the metaweb
# 
stopifnot(  sum(degree(redl,mode="in")==0) == websTbl %>% filter(Network==metaweb_name) %>% select(Basal) )

metaweb_name <- str_sub(metaweb_name,1,3)

A <- get.adjacency(redl,sparse=F)
dimA <- nrow(A)

# Simulate a grid of parameters to select the best options using latin hypercubic sampling
#
#
# Use require(lhs)
# https://cran.r-project.org/web/packages/lhs/vignettes/lhs_basics.html
#
# Combine parameters

#    min(m)    max(m)      min(a)    max(a)
#   0.100000     0.3         0.001     0.5

require(lhs)

# simulations with probability of secondary extinction == 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 1, 1),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2, 150000, par_ranges,A, 1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# simulations with probability of secondary extinction != 1
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0.1, 0.9),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(3, 150000, par_ranges,A, 1) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")


# simulations with probability of secondary extinction == 0
#
# Discrete time
par_ranges <- matrix(c(0.01, 0.3,0.001, 0.5, 0, 0),nrow=3,byrow = TRUE)
sim <- sim_metaWebAssembly_lhs(2,  150000, par_ranges,A,1 ) %>% mutate(model_type="Continuous",Metaweb=metaweb_name)

simMetaWebAssembly <- bind_rows(simMetaWebAssembly,sim)
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

# Set the type of models according to probability of secondary extinction
#
#simMetaWebAssembly <- readRDS("Data/simulations_metaWebAssembly.rds")
simMetaWebAssembly <- simMetaWebAssembly %>% mutate(model = ifelse(se==1, "Fixed", ifelse(se>0, "Prob", "No SecExt") ))
knitr::kable(simMetaWebAssembly %>% group_by(Metaweb,model,model_type) %>% summarise(n=n()))

# Save the updated dataset with all simulations and models: 3 metawebs, 3 models, 150000*9=1350000 records  
#
saveRDS(simMetaWebAssembly,"Data/simulations_metaWebAssembly.rds")

(p2 <- ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,C))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Connectance,color=Network),size=0.5) + 
  coord_cartesian(ylim=c(0.05,.5)) + 
  facet_wrap(~ model) + scale_color_brewer(palette= "Paired",guide=FALSE))

ggplot(simMetaWebAssembly %>% filter(Metaweb == metaweb_name), aes(S,L))+ geom_point(size=0.1,alpha=0.5) + theme_bw() + 
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network)), aes(Size,Links,color=Network),size=0.3) + 
  coord_cartesian(ylim=c(0,3000)) + 
  facet_wrap(~model)  + scale_color_brewer(palette= "Dark2")

# ggsave("Figures/Metaweb_Continuous_Discrete.pdf",width=8,height=5,units="in",dpi=600)

rm(p1,p2,ga,have1,Have_df,dtot1,df_list,redl,simMetaWebAssembly)
save.image()
```

## Make the fit Lakes

```{r fitMetaWebLakes, eval=FALSE,echo=F,message=T,warning=T}
#
#
# Use this tolerance = tol to display a more detailed plot 

netnames <- names(ig_list)
netnames <- netnames[ netnames != "Lak_Meta" ] 
fmw <-  lapply(netnames, function(n){

  fit_metaWebAssembly_model(websTbl, n, simMetaWebAssembly)
  
})

fittedMetaWeb <- bind_rows(fittedMetaWeb, fmw)

## Perform ABC and GOF
#
# fmw <-  lapply(netnames, function(n){
# 
#   CI_metaWebAssembly_model(websTbl, n, simMetaWebAssembly)
# })
# fittedMetaWeb_gof <- bind_rows(fittedMetaWeb_gof,fmw)
# fittedMetaWeb_gof <- fittedMetaWeb_gof %>% mutate(Metaweb = str_sub(Network,1,3)) %>% dplyr::select( Metaweb,Network,  everything())
# #  
# fittedMetaWeb_gof %>% mutate(fit=gof_pvalue>0.1) %>% group_by(model,fit) %>% summarise(n=n()) %>% mutate(freq=n/sum(n))
# knitr::kable(fittedMetaWeb_gof %>% ungroup() %>%  dplyr::select(-model_type,-fit_type) %>% arrange(Network), digits = 4)


knitr::kable(fittedMetaWeb %>% ungroup() %>% dplyr::select( Metaweb,Network,  everything() )%>% dplyr::select(-min_dist, -model_type,-fit_type) %>% arrange(Network), digits = 4)

rm(netnames,fmw,X,dfA,AAdf,AAdf1,AAdf2,AAdf3,arguments,sim,sel,g3,gg,ga,ravg,sel,redl,ig_list,web,have1,Have_df)
save.image()

```

# Make simulations with fitted parameters with S-C method

* As connectivity is determines most of other network properties we fit by connectivity and number of species


```{r fitMetaWebSims, eval=FALSE,echo=F,message=T,warning=T}

knitr::kable( fittedMetaWeb %>% group_by(Metaweb,Network) %>% top_n(-1,distance) %>% ungroup() %>% group_by(model) %>% summarise(n=n()) %>% mutate(freq = n / sum(n)))

# Ant_Meta
# Lak_Meta
# Isl_Meta


#
# Potter - No SecExt (best fit)
#
simulate_plot_metaweb_assembly(Ant_Meta,fittedMetaWeb,websTbl,"Ant_Potter")

#
# Weddell - Prob
#
simulate_plot_metaweb_assembly(Ant_Meta,fittedMetaWeb,websTbl,"Ant_Weddell")

#
# Isl_FloridaIslandE3 - Prob
#
simulate_plot_metaweb_assembly(Isl_Meta,fittedMetaWeb,websTbl,"Isl_FloridaIslandE3")

#
# Isl_FloridaIslandE9 - Fixed
#
simulate_plot_metaweb_assembly(Isl_Meta,fittedMetaWeb,websTbl,"Isl_FloridaIslandE9")

#
# Lak_Hoel_lake - Fixed
#
simulate_plot_metaweb_assembly(Lak_Meta,fittedMetaWeb,websTbl,"Lak_Hoel_lake")


#
# Lak_Federation_lake - Fixed
#
simulate_plot_metaweb_assembly(Lak_Meta,fittedMetaWeb,websTbl,"Lak_Federation_lake")

```



# Local web (Potter Cove) compared to  metaWeb assembly model (TEST)


```{r PotterGlobalMetaWebAssembly, eval=FALSE,echo=F,message=T,warning=T}

A <- get.adjacency(Ant_Meta,sparse=F)
      

#
# Select Local food web 
# 
net_name <- pull( websTbl %>% filter(!ismeta) %>% dplyr::select(Network) )
f <- fittedMetaWeb %>% filter(Network == net_name[1])
tictoc::tic()
tbl <- calc_modularity_metaWebAssembly(websTbl, net_name[1], A, f$m[1], f$a[1], f$se[1],1000)
tictoc::toc()
sim <- tbl$sim

tblMdlWeb <- tbl$su %>% mutate(Network=net_name[1],model=f$model[1]) %>% inner_join(dplyr::select(websTbl,Network:Modularity)) %>%
  dplyr::select(Network:Modularity,mdlCC:zMEing)

#
# Correct the calculation of z-score
#
if(!exists("websAssemblyModel")) websAssemblyModel <- tibble()
websAssemblyModel <- websAssemblyModel %>% bind_rows(tblMdlWeb) 
if( !exists("websAssemblyModelSim")) websAssemblyModelSim <- tibble()
websAssemblyModelSim <-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network=net_name[1],model=f$model[1]))  
rm(sim,tblMdlWeb,tbl,f)
save.image()



```



# Antarctic Metaweb assembly model 

```{r AntarcticMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModel")) websAssemblyModel <- tibble()
if(!exists("websAssemblyModelSim")) websAssemblyModelSim <- tibble()

A <- get.adjacency(Ant_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Ant") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_modularity_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)
    tictoc::tic("calc_modularity_metaWebAssembly")
    tbl <- calc_modularity_metaWebAssembly(websTbl, fw, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()
    sim <- tbl$sim
    
    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network:Modularity)) %>%
                            dplyr::select(Network:Modularity,mdlCC:zMO)

    websAssemblyModel <<- websAssemblyModel %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSim <<-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()

```

# Islands Metaweb assembly model 

```{r IslMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModel")) websAssemblyModel <- tibble()
if(!exists("websAssemblyModelSim")) websAssemblyModelSim <- tibble()

A <- get.adjacency(Isl_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Isl") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){

    message(paste("\ncalc_modularity_metaWebAssembly", fw, model_name))

    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)
    tbl <- calc_modularity_metaWebAssembly(websTbl, fw, A, f$m[1], f$a[1], f$se[1],10)
    sim <- tbl$sim

    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network:Modularity)) %>%
                            dplyr::select(Network:Modularity,mdlCC:zMO)

    websAssemblyModel <<- websAssemblyModel %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSim <<-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()

```


# Lakes Metaweb assembly model 

```{r LakMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModel")) websAssemblyModel <- tibble()
if(!exists("websAssemblyModelSim")) websAssemblyModelSim <- tibble()

A <- get.adjacency(Lak_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Lak") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){

    message(paste("\ncalc_modularity_metaWebAssembly", fw, model_name))

    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)
    tbl <- calc_modularity_metaWebAssembly(websTbl, fw, A, f$m[1], f$a[1], f$se[1],1000)
    sim <- tbl$sim

    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network:Modularity)) %>%
                            dplyr::select(Network:Modularity,mdlCC:zMO)

    websAssemblyModel <<- websAssemblyModel %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSim <<-websAssemblyModelSim %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()

```


## Plots of the distribution of simulated indices

```{r WeddellGlobalMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Plots of the distribution of simulated indices
#
net_name <- pull( websTbl %>% filter(!ismeta) %>% dplyr::select(Network) )
model_name <- "Prob"

# Add Conecctance to summary table websAssemblyModel
#
if( !("C" %in% names(websAssemblyModelSim)) ) { 
  websAssemblyModelSim <- websAssemblyModelSim %>% mutate(C = Links/(Size^2))
  websAssemblyModel <- websAssemblyModelSim %>% group_by(model,Network) %>% group_modify( ~{ qq <- quantile(.x$C,c(0.005,0.995))
                                                                        ss <- quantile(.x$Size,c(0.005,0.995))
                                                                        tibble(Clow = qq[1],Chigh=qq[2],Slow=ss[1],Shigh=ss[2])
                                                                        }) %>% inner_join( websAssemblyModel )
}
require(RColorBrewer)
col <- brewer.pal(8,"Dark2")
col <- c("#0097A7","#448AFF","#212121")


#
# Plots for All Networks
#
require(cowplot)

lapply(net_name, function(fw){

  dat <- websAssemblyModel %>% filter(Network==fw,model=="Prob") %>% rename(modularity=Modularity,C=Connectance) %>%
    bind_cols(websTbl %>% filter(Network==fw) %>% dplyr::select(Q,mTI))
  sim <- websAssemblyModelSim %>% filter(Network==fw,model=="Prob") 
  
  p1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=SWness, y=85, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=55, yend = 0), colour=col[2], size=.8, linetype=1 )
  
  p2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=Q, y=30, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[2], size=.8, linetype=1 )
  
  p3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=mTI, y=25, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=18, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=18, yend = 0), colour=col[2], size=.8, linetype=1 )
  
  
  p4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
      geom_segment(data=dat,aes(xend=modularity, y=25, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=18, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=18, yend = 0), colour=col[2], size=.8, linetype=1 )
  
  p5 <- ggplot(sim,aes(C))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=C, y=85, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=Clow,xend=Clow, y=18, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=Chigh,xend=Chigh, y=18, yend = 0), colour=col[2], size=.8, linetype=1 )

  p6 <- plot_grid(p5,p2+ylab(""),p3+ylab(""),p4+ylab(""),p1+ylab(""),align = "h",nrow=1)
  
  save_plot(paste0("Figures/",fw,"_Metrics_assembly_mdl.png"),p6,base_width=8,base_height=4,dpi=600)
})


lapply(net_name, function(fw){

  dat <- websAssemblyModel %>% filter(Network==fw,model=="Prob") %>% rename(modularity=Modularity,C=Connectance) %>%
    bind_cols(websTbl %>% filter(Network==fw) %>% dplyr::select(Q,mTI))
  sim <- websAssemblyModelSim %>% filter(Network==fw,model=="Prob") 
  
  h <- hist(sim$Size)
  y_end <- round(max(h$counts)* .12)
  y_end1 <- round(max(h$counts)* .08)
  
  p2 <- ggplot(sim,aes(Size))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=Size, y=y_end, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=Slow,xend=Slow, y=y_end1, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=Shigh,xend=Shigh, y=y_end1, yend = 0), colour=col[2], size=.8, linetype=1 )

  h <- hist(sim$C)
  y_end <- round(max(h$counts)* .12)
  y_end1 <- round(max(h$counts)* .08)
  
  p5 <- ggplot(sim,aes(C))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
      geom_segment(data=dat,aes(xend=C, y=y_end, yend = 0), colour=col[3], size=.8, arrow = arrow(length = unit(0.5, "cm"))) +
      geom_segment(data=dat,aes(x=Clow,xend=Clow, y=y_end1, yend = 0), colour=col[2], size=.8, linetype=1 ) +
      geom_segment(data=dat,aes(x=Chigh,xend=Chigh, y=y_end1, yend = 0), colour=col[2], size=.8, linetype=1 )

  p6 <- plot_grid(p2,p5+ylab(""),align = "h",nrow=1)
  
  save_plot(paste0("Figures/",fw,"_CS_assembly_mdl.png"),p6,base_width=8,base_height=4,dpi=600)
})

#
# Table with Significance: empirical value is outside CI = TRUE 
#
names(websAssemblyModel)
sign <- websAssemblyModel %>% rename(modularity=Modularity,C=Connectance) %>% inner_join(websTbl %>% dplyr::select(Network,Q)) %>% transmute( C_sign = C > Chigh  | C < Clow, S_sign= Size> Shigh | Size< Slow, MO_sign = modularity > MOhigh | modularity < MOlow,TI_sign = TLmean > TIhigh | TLmean < TIlow, Q_sign = Q > Qhigh | Q < Qlow, SWness_sign = SWness > SWnessCI )

#
# Example Plot for the Figure 1 
#
# dat <- websAssemblyModel %>% filter(Network==net_name[1],model=="Prob") %>% rename(modularity=Modularity,C=Connectance) %>% bind_cols(websTbl %>% filter(Network==net_name[1]) %>% dplyr::select(Q,mTI))
# sim <- websAssemblyModelSim %>% filter(Network==net_name[1],model=="Prob") 
# 
# p <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_classic() + xlab("Network metric")
# p + geom_segment(data=dat,aes(x=Q+0.4,xend=Q+0.4, y=30, yend = 0), colour=col[2], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=20, yend = 0), colour=col[3], size=1, linetype=1 ) +
#     geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=20, yend = 0), colour=col[3], size=1, linetype=1 )
    
# dat <- websAssemblyModel %>% filter(Network==net_name[2],model=="Prob") %>% rename(modularity=Modularity) %>% bind_cols(websTbl %>% filter(Network==net_name[1]) %>% dplyr::select(Q,mTI))
# sim <- websAssemblyModelSim %>% filter(Network==net_name[2],model=="Prob")
# 
# q1 <- ggplot(sim,aes(SWness))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
#     geom_segment(data=dat,aes(xend=SWness, y=185, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=SWnessCI,xend=SWnessCI, y=120, yend = 0), colour=col[2], size=1, linetype=1 )
# 
# 
# q2 <- ggplot(sim,aes(Q))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
#     geom_segment(data=dat,aes(xend=Q, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=Qlow,xend=Qlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
#     geom_segment(data=dat,aes(x=Qhigh,xend=Qhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )
# 
# q3 <- ggplot(sim,aes(mTI))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() + 
#     geom_segment(data=dat,aes(xend=mTI, y=32, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=TIlow,xend=TIlow, y=21, yend = 0), colour=col[2], size=1, linetype=1 ) +
#     geom_segment(data=dat,aes(x=TIhigh,xend=TIhigh, y=21, yend = 0), colour=col[2], size=1, linetype=1 )
# 
# 
# q4 <- ggplot(sim,aes(modularity))+ geom_histogram(alpha=0.5,fill=col[1],color=col[1]) + theme_bw() +
#     geom_segment(data=dat,aes(xend=modularity, y=24, yend = 0), colour=col[3], size=1, arrow = arrow(length = unit(0.5, "cm"))) +
#     geom_segment(data=dat,aes(x=MOlow,xend=MOlow, y=16, yend = 0), colour=col[2], size=1, linetype=1 ) +
#     geom_segment(data=dat,aes(x=MOhigh,xend=MOhigh, y=16, yend = 0), colour=col[2], size=1, linetype=1 )
# 
# 
# require(cowplot)
# p5 <- plot_grid(q1+xlab(""),q2+ylab("")+xlab(""),q3+ylab("")+xlab(""),q4+ylab("")+xlab(""),
#                 p1,p2+ylab(""),p3+ylab(""),p4+ylab(""),align = "h",nrow=2,labels = c("Potter","","","","Wedell"))
# save_plot("Figures/Ant_Prop_assembly_ByNetwork.png",p5,base_width=8,base_height=5,dpi=600)



```


# Antarctic Metaweb assembly model QSS

```{r AntQSSMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
#if(!exists("websAssemblyModelQSS")) 
websAssemblyModelQSS <- tibble()
#if(!exists("websAssemblyModelSimQSS")) 
websAssemblyModelSimQSS <- tibble()

A <- get.adjacency(Ant_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Ant") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_qss_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name) %>% inner_join(websTbl %>% dplyr::select(Network,QSS,MEing))
    tictoc::tic("calc_qss_metaWebAssembly")
    tbl <- calc_qss_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000,ncores=48)
    tictoc::toc()
    sim <- tbl$sim
    
    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network,QSS,MEing)) 

    websAssemblyModelQSS <<- websAssemblyModelQSS %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSimQSS <<-websAssemblyModelSimQSS %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()

```

# Islands Metaweb assembly model QSS

```{r IslQSSMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModelQSS")) websAssemblyModelQSS <- tibble()
if(!exists("websAssemblyModelSimQSS")) websAssemblyModelSimQSS <- tibble()

A <- get.adjacency(Isl_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Isl") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_qss_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name) %>% inner_join(websTbl %>% dplyr::select(Network,QSS,MEing))
    tictoc::tic("calc_qss_metaWebAssembly")
    # (red, Adj, mig,ext,sec,nsim=1000,final_time=1000,ncores=0)
    tbl <- calc_qss_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000,ncores=48)
    tictoc::toc()
    sim <- tbl$sim
    
    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network,QSS,MEing)) 

    websAssemblyModelQSS <<- websAssemblyModelQSS %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSimQSS <<-websAssemblyModelSimQSS %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()


```

#  Lakes Metaweb assembly model QSS

```{r LakQSSMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}
if(!exists("websAssemblyModelQSS")) websAssemblyModelQSS <- tibble()
if(!exists("websAssemblyModelSimQSS")) websAssemblyModelSimQSS <- tibble()

A <- get.adjacency(Lak_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Lak") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_qss_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name) %>% inner_join(websTbl %>% dplyr::select(Network,QSS,MEing))
    tictoc::tic("calc_qss_metaWebAssembly")
    tbl <- calc_qss_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000,ncores=48)
    tictoc::toc()
    sim <- tbl$sim
    
    tblMdlWeb <- tbl$su %>% mutate(Network=fw,model=model_name) %>% inner_join(dplyr::select(websTbl,Network,QSS,MEing)) 

    websAssemblyModelQSS <<- websAssemblyModelQSS %>% bind_rows(tblMdlWeb) 
    websAssemblyModelSimQSS <<-websAssemblyModelSimQSS %>% bind_rows(sim %>% mutate(Network=fw,model=model_name))  
})
save.image()
```

# All Metrics - S and C and MEing - results Plots & tables  

```{r PotterMotifMetaWebAssembly, eval=F,echo=F,message=T,warning=T}

#
# Table with Significance: empirical value is outside CI = TRUE 
#
websAssemblyModel <-  websAssemblyModel %>% select(model:zMO) %>% inner_join(websAssemblyModelQSS)
sign <- websAssemblyModel %>% rename(modularity=Modularity,C=Connectance) %>% inner_join(websTbl %>% dplyr::select(Network,Q)) %>% transmute( C_sign = C > Chigh  | C < Clow, S_sign= Size> Shigh | Size< Slow, MO_sign = modularity > MOhigh | modularity < MOlow,TI_sign = TLmean > TIhigh | TLmean < TIlow, Q_sign = Q > Qhigh | Q < Qlow, SWness_sign = SWness > SWnessCI , MEing_gt = MEing > MEingHigh  , MEing_lw = MEing < MEingLow )

knitr::kable(sign)

knitr::kable(websAssemblyModel %>% inner_join(websTbl %>% dplyr::select(Network,Q)) %>% select(Size, Slow,Shigh,Connectance,Clow,Chigh,TLmean,TIlow,TIhigh,Q,Qlow,Qhigh,MEing,MEingLow,MEingHigh))

names(websAssemblyModel)
names(websAssemblyModelQSS)
websAssemblyModelQSS  %>% mutate( MEing_gt = MEing > MEingHigh  , MEing_lw = MEing < MEingLow) %>% filter(MEing_gt | MEing_lw)


names(websAssemblyModelSimQSS)
metaweb_name <- "Ant"

websAssemblyModelSimQSS %>% filter((grepl(metaweb_name,Network))) %>% mutate(C=Links/(Size^2)) %>%
ggplot( aes(C,MEing))+ geom_point(size=1,alpha=0.5) + stat_ellipse(aes(color=Network)) + theme_bw() +
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network),!ismeta), aes(Connectance,MEing,color=Network),size=0.5) + 
  # coord_cartesian(ylim=c(0.01,0.1)) +  
  facet_wrap(~ Network) + scale_color_brewer(palette= "Paired", guide=FALSE) 


websAssemblyModelSimQSS %>% filter((grepl(metaweb_name,Network))) %>% mutate(C=Links/(Size^2)) %>%
ggplot( aes(Size,MEing))+ geom_point(size=1,alpha=0.5) + stat_ellipse(aes(color=Network)) + theme_bw() +
  geom_point(data=websTbl %>% filter(grepl(metaweb_name,Network),!ismeta), aes(Size,MEing,color=Network),size=0.5) + 
  # coord_cartesian(ylim=c(0.01,0.1)) +  
  facet_wrap(~ Network) + scale_color_brewer(palette= "Paired", guide=FALSE) 

nets <- c("Lak_Bridge_brook_lake","Lak_Chub_pond", "Lak_Hoel_lake","Lak_Long_Lake")
websAssemblyModelSimQSS %>% filter(Network %in% nets) %>% mutate(C=Links/(Size^2)) %>%
ggplot( aes(Size,MEing))+ geom_point(size=1,alpha=0.5) + stat_ellipse(aes(color=Network)) + theme_bw() +
  geom_point(data=websTbl %>% filter(Network %in% nets), aes(Size,MEing,color=Network),size=1,alpha=1) + 
  # coord_cartesian(ylim=c(0.01,0.1)) +  
  facet_wrap(~ Network) + scale_color_brewer(palette= "Paired", guide=FALSE) 

#
# 
#
websAssemblyModelQSS <- websAssemblyModelQSS %>% select(Network,model, everything()) %>%  mutate(Metaweb=str_sub(Network,1,3),   Net_name = gsub('([a-z])([A-Z])', '\\1 \\2', str_sub(Network,5)) %>% str_replace_all('_',' ' ))

require(tidyverse)
ggplot(websAssemblyModelQSS, aes(x=fct_reorder(Net_name,Metaweb),y=MEing,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ theme_bw() + ylab("MEing")  + xlab(NULL) + geom_errorbar(aes(ymin=MEingLow, ymax=MEingHigh), width=.10) +
  #theme(axis.text.x=element_blank()) + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size=7))  
ggsave("Figures/MEing_Assembly_byMeta.png",width=8,height=6,units="in",dpi=600)


names( websAssemblyModel)

websAssemblyModel %>% inner_join(websTbl %>% dplyr::select(Network,Q))  %>% mutate(Metaweb=str_sub(Network,1,3),Net_name = gsub('([a-z])([A-Z])', '\\1 \\2', str_sub(Network,5)) %>% str_replace_all('_',' ' )) %>% 
  ggplot( aes(x=fct_reorder(Net_name,Metaweb),y=Q,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Q")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=Qlow, ymax=Qhigh), width=.10) +
  #theme(axis.text.x=element_blank())
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size=7))  
ggsave("Figures/Q_Assembly_byMeta.png",width=8,height=6,units="in",dpi=600)


websAssemblyModel %>% mutate(Metaweb=str_sub(Network,1,3),Net_name = gsub('([a-z])([A-Z])', '\\1 \\2', str_sub(Network,5)) %>% str_replace_all('_',' ' )) %>% 
  ggplot( aes(x=fct_reorder(Net_name,Metaweb),y=Modularity,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Modularity")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=MOlow, ymax=MOhigh), width=.10) +   
  #theme(axis.text.x=element_blank())
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size=7))  
ggsave("Figures/Modularity_Assembly_byMeta.png",width=8,height=6,units="in",dpi=600)


websAssemblyModel %>% mutate(Metaweb=str_sub(Network,1,3),Net_name = gsub('([a-z])([A-Z])', '\\1 \\2', str_sub(Network,5)) %>% str_replace_all('_',' ' )) %>% 
  ggplot( aes(x=fct_reorder(Net_name,Metaweb),y=TLmean,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Mean Trophic Level")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=TIlow, ymax=TIhigh), width=.10) +   
  #theme(axis.text.x=element_blank())
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size=7))
ggsave("Figures/TL_Assembly_byMeta.png",width=8,height=6,units="in",dpi=600)


websAssemblyModel %>% mutate(Metaweb=str_sub(Network,1,3),Net_name = gsub('([a-z])([A-Z])', '\\1 \\2', str_sub(Network,5)) %>% str_replace_all('_',' ' )) %>%
  ggplot( aes(x=fct_reorder(Net_name,Metaweb),y=Connectance,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Connectance")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=Clow, ymax=Chigh), width=.10) +   
  #theme(axis.text.x=element_blank())
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size=7))
ggsave("Figures/Connectance_Assembly_byMeta.png",width=8,height=6,units="in",dpi=600)


websAssemblyModel %>% mutate(Metaweb=str_sub(Network,1,3),Net_name = gsub('([a-z])([A-Z])', '\\1 \\2', str_sub(Network,5)) %>% str_replace_all('_',' ' )) %>%
  ggplot( aes(x=fct_reorder(Net_name,Metaweb),y=Size,color=Metaweb)) + geom_point() +scale_color_brewer(palette = "Paired")+ 
  theme_bw() + ylab("Size")  + xlab(NULL) + 
  geom_errorbar(aes(ymin=Slow, ymax=Shigh), width=.10) +   
  #theme(axis.text.x=element_blank())
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size=7))

ggsave("Figures/Size_Assembly_byMeta.png",width=8,height=6,units="in",dpi=600)


# + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)



```


# Motif Antarctic compared to  metaWeb assembly model 

```{r AntMotifMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}

#if(!exists("websAssemblyModelQSS")) 
motif_AssemblyModel <- tibble()

A <- get.adjacency(Ant_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Ant") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_motif_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)  %>% inner_join(motif_ER %>% dplyr::select(Network,explComp:omnivory))
    tictoc::tic("calc_motif_metaWebAssembly")
    tbl <- calc_motif_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()

    tblMdlWeb <- tbl %>% mutate(Network=fw,model=model_name) %>% select(Network, model, everything())

    motif_AssemblyModel <<- motif_AssemblyModel %>% bind_rows(tblMdlWeb) 
})
save.image()
```


# Motif Islands compared to  metaWeb assembly model 

```{r IslMotifMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}

#if(!exists("websAssemblyModelQSS")) 
#motif_AssemblyModel <- tibble()

A <- get.adjacency(Isl_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Isl") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_motif_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)  %>% inner_join(motif_ER %>% dplyr::select(Network,explComp:omnivory))
    tictoc::tic("calc_motif_metaWebAssembly")
    tbl <- calc_motif_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()

    tblMdlWeb <- tbl %>% mutate(Network=fw,model=model_name) %>% select(Network, model, everything())

    motif_AssemblyModel <<- motif_AssemblyModel %>% bind_rows(tblMdlWeb) 
})
save.image()
```

# Motif Lakes compared to  metaWeb assembly model 

```{r LakMotifMetaWebAssembly, eval=FALSE,echo=F,message=FALSE,warning=T}

#if(!exists("websAssemblyModelQSS")) 
#motif_AssemblyModel <- tibble()

A <- get.adjacency(Lak_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Lak") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_motif_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)  %>% inner_join(motif_ER %>% dplyr::select(Network,explComp:omnivory))
    tictoc::tic("calc_motif_metaWebAssembly")
    tbl <- calc_motif_metaWebAssembly(f, fw, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()

    tblMdlWeb <- tbl %>% mutate(Network=fw,model=model_name) %>% select(Network, model, everything())

    motif_AssemblyModel <<- motif_AssemblyModel %>% bind_rows(tblMdlWeb) 
})
save.image()
```



# Tables Motif compared to  metaWeb assembly model 

```{r TablesMotifMetaWebAssembly, eval=FALSE,echo=F,message=T,warning=T}

#
# Table with Significance: empirical value is outside CI = TRUE 
#
sign <- motif_AssemblyModel %>% transmute( Network=Network, zEC = explComp > EChigh  | explComp < EClow, zAC= apprComp> AChigh | apprComp< AClow, zTT = triTroph > TThigh | triTroph < TTlow, zOM = omnivory > OMhigh | omnivory < OMlow)
knitr::kable(sign)

# Format motif z-score tibble
#
#
require(tidyr)
names(motif_AssemblyModel)
pFM1 <- motif_AssemblyModel %>% dplyr::select(Network,zEC:zOM) %>%gather(motif,Zscore,zEC:zOM) %>% mutate(type="Random z-score")
pFM1$Network <- factor(pFM1$Network)
#levels(pFM1$Network) <- c("Potter Cove","Meta-web","Weddell Sea")

# Normalize z-scores
#
pFM1 <- pFM1 %>% group_by(Network) %>% mutate(normZ=Zscore/sum(sqrt(Zscore^2)), Metaweb=str_sub(Network,1,3)) 
 

# Add asteriscs to significative motifs
#

sign_lbl <- sign %>% pivot_longer(!Network,values_to = "sign",names_to = "motif") %>% mutate(label=ifelse(sign, "*", "")) %>% inner_join(pFM1) %>% mutate( Network = gsub('([a-z])([A-Z])', '\\1 \\2', str_sub(Network,5)) %>% str_replace_all('_',' ' ))

g1 <- ggplot(sign_lbl,
        aes(x=fct_inorder(Network),y=Zscore,fill=motif,label=label)) + geom_bar(stat="identity",position=position_dodge()) +
   scale_fill_brewer(palette = "Paired",breaks=c("zAC","zEC","zOM","zTT"),name="Motif\nZ-score",   labels=c("Apparent\ncompetition","Exploitative\ncompetition","Omnivory", "Tri-trophic\nchain")) + #guides(fill=FALSE) +
   xlab("") + ylab("") + theme_bw() +  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size=7)) + 
  #facet_wrap(~Metaweb, ncol = 1, scale="free") + 
  geom_text(position=position_dodge(width=0.9))
g1
ggsave("Figures/Motif_Zscores_Assembly.png",width=8,height=6,units="in",dpi=600)



```

# Topological roles with meta-web assembly model 

```{r MetaWebTopologicalRoles, eval=TRUE,echo=F,message=F,warning=T}
topoRoles_metaWebAssembly <- tibble()
hub_conn_Assembly <- tibble()
set.seed(1234)

# Antarctic 
#
A <- get.adjacency(Ant_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Ant") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){

    message(paste("\ncalc_topoRoles_metaWebAssembly", fw, model_name))


    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)
    tictoc::tic("calc_topoRoles_metaWebAssembly")
    tbl <- calc_topoRoles_metaWebAssembly(fw,f$S, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()
    topoRoles_metaWebAssembly <<- topoRoles_metaWebAssembly %>% bind_rows(tbl$tr %>% mutate(model=model_name))
    hub_conn_Assembly <<-hub_conn_Assembly %>% bind_rows(tbl$hc %>% mutate(model=model_name))
})

save.image()

# Islands
#

A <- get.adjacency(Isl_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Isl") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){

    message(paste("\ncalc_topoRoles_metaWebAssembly", fw, model_name))


    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name)
    tictoc::tic("calc_topoRoles_metaWebAssembly")
    tbl <- calc_topoRoles_metaWebAssembly(fw,f$S, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()
    topoRoles_metaWebAssembly <<- topoRoles_metaWebAssembly %>% bind_rows(tbl$tr %>% mutate(model=model_name))
    hub_conn_Assembly <<-hub_conn_Assembly %>% bind_rows(tbl$hc %>% mutate(model=model_name))
})

save.image()

# Lakes I added the check than the modeled web is no lower than the 80% of mean Species size
# This is important for the smaller webs where the varibility could be large
#
A <- get.adjacency(Lak_Meta,sparse=F)
net_name <- pull( websTbl %>% filter(!ismeta,Metaweb=="Lak") %>% dplyr::select(Network) )
model_name <- "Prob"

lapply(net_name, function(fw){ 
  
    message(paste("\ncalc_topoRoles_metaWebAssembly", fw, model_name))

  
    f <- fittedMetaWeb %>% filter(Network == fw, model==model_name) 
    tictoc::tic("calc_topoRoles_metaWebAssembly")
    tbl <- calc_topoRoles_metaWebAssembly(fw,f$S, A, f$m[1], f$a[1], f$se[1],1000)
    tictoc::toc()
    topoRoles_metaWebAssembly <<- topoRoles_metaWebAssembly %>% bind_rows(tbl$tr %>% mutate(model=model_name)) 
    hub_conn_Assembly <<-hub_conn_Assembly %>% bind_rows(tbl$hc %>% mutate(model=model_name))  
})

save.image()
```

# Plots/tests of Topological roles with meta-web assembly model 

```{r plotsMetaWebTopologicalRoles, eval=FALSE,echo=F,message=T,warning=T}

# Antarctica
# Topological Roles proportions test and plot
#
#

# Antarctic
#

# Comparison of model with empirical  
# 
hc <- hub_conn %>% filter(grepl("Ant",Network)) %>% bind_rows(
  hub_conn_Assembly %>% filter(grepl("Ant",Network)) %>% select(type,node,Network) %>% mutate(model="Assembly")) %>% 
  mutate(model=ifelse(is.na(model),"Empirical",model)) %>% group_by(Network,model,type) %>% summarise(count=n()) %>% mutate(total=sum(count),Freq=count/total) %>% inner_join(websTbl %>% select(Network,Size))
str_length(hc$Network)
hc <-  hc %>% ungroup() %>% mutate(Network = ifelse(str_length(Network) > 8, str_sub(Network,5), paste0(str_sub(Network,5),"web"))) %>% mutate(Network = fct_reorder(Network, -Size))
 

tt1 <- hc %>% group_by(Network) %>% group_modify( ~{ 
  ct <- .x %>% pivot_wider(model:count,names_from="type",values_from = "count",values_fill = list(count = 0)) 
  cc <- chisq.test(ct[,-1],simulate.p.value = TRUE, B=10000)
  #ct <- 
  #print(ct)
  tibble(Size=unique(.x$Size),chi2=cc$statistic,pvalue = cc$p.value,method=cc$method)
  }) %>% arrange(desc(Size)) %>% mutate(meta="Ant")

names(tt1)
names(hc)

hc <- inner_join(hc, tt1 %>% select(Network,pvalue)) %>% mutate(net_name=if_else(pvalue<0.05, if_else(!grepl("Meta",Network), paste0(Network, ' *'),as.character(Network)),as.character(Network)))

(gP2 <- ggplot(hc,aes(x=model,y=Freq,fill=type)) + 
  geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + 
    theme(legend.position="bottom", legend.direction="horizontal",   strip.background = element_blank(), strip.placement = "outside") +
    facet_wrap(vars(net_name)))
ggsave("Figures/Ant_TopoRoles_ByNetwork_Model.png",width=8,height=5,units="in",dpi=600)



```

# Islands - Plots/tests of Topological roles with meta-web assembly model 

```{r Isl_plotsMetaWebTopologicalRoles, eval=FALSE,echo=F,message=T,warning=T}

# islands
#

# Comparison of model with empirical  
# 
hc <- hub_conn %>% filter(grepl("Isl",Network)) %>% bind_rows(
  hub_conn_Assembly %>% filter(grepl("Isl",Network)) %>% select(type,node,Network) %>% mutate(model="Assembly")) %>% 
  mutate(model=ifelse(is.na(model),"Empirical",model)) %>% group_by(Network,model,type) %>% summarise(count=n()) %>% mutate(total=sum(count),Freq=count/total) %>% inner_join(websTbl %>% select(Network,Size))

hc <-  hc %>% ungroup() %>% mutate(Network = ifelse(str_length(Network) > 8, str_sub(Network,18), paste0(str_sub(Network,5),"web"))) #%>% mutate(Network = fct_reorder2(Network, -Size, Network))
 

tt0 <- hc %>% group_by(Network) %>% group_modify( ~{ 
  ct <- .x %>% pivot_wider(model:count,names_from="type",values_from = "count",values_fill = list(count = 0)) 
  cc <- chisq.test(ct[,-1],simulate.p.value = TRUE, B=10000)
  #ct <- 
  #print(ct)
  tibble(Size=unique(.x$Size),chi2=cc$statistic,pvalue = cc$p.value,method=cc$method)
  }) %>% arrange(desc(Size)) %>% mutate(meta="Isl")

hc <- inner_join(hc, tt0 %>% select(Network,pvalue)) %>% mutate(net_name=if_else(pvalue<0.05, if_else(!grepl("Meta",Network), paste0(Network, ' *'),as.character(Network)),as.character(Network)))


(gP2 <- ggplot(hc,aes(x=model,y=Freq,fill=type)) + 
  geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + 
    theme(legend.position="bottom", legend.direction="horizontal",   strip.background = element_blank(), strip.placement = "outside") + 
    facet_wrap(vars(fct_reorder2(net_name, -Size, Network ))))

ggsave("Figures/Isl_TopoRoles_ByNetwork_Model.png",width=8,height=5,units="in",dpi=600)

tt0 %>% summarize(sign = pvalue<0.05) %>% filter(sign) 
topoRoles_metaWebAssembly_chi2 <- bind_rows(tt1,tt0)
```

* There is total correspondence with model

# Lakes - Plots/tests of Topological roles with meta-web assembly model 

```{r Isl_plotsMetaWebTopologicalRoles, eval=FALSE,echo=F,message=T,warning=T}
require(tidyverse)
# Lakes

#
# Comparison of model with empirical  
# 
hc <- hub_conn %>% filter(grepl("Lak",Network)) %>% bind_rows(
  hub_conn_Assembly %>% filter(grepl("Lak",Network)) %>% select(type,node,Network) %>% mutate(model="Assembly")) %>% 
  mutate(model=ifelse(is.na(model),"Empirical",model)) %>% group_by(Network,model,type) %>% summarise(count=n()) %>% mutate(total=sum(count),Freq=count/total) %>% inner_join(websTbl %>% select(Network,Size))

hc <- hc %>% ungroup() %>% mutate( Network = gsub('([a-z])([A-Z])', '\\1 \\2', str_sub(Network,5)) %>% str_replace_all('_',' ' )) %>% mutate(Network=ifelse(Network=="Meta","Metaweb",Network)) #%>%  mutate(Network = fct_reorder(Network, -Size))

tt <- hc %>% group_by(Network) %>% group_modify( ~{ 
  ct <- .x %>% pivot_wider(model:count,names_from="type",values_from = "count",values_fill = list(count = 0)) 
  cc <- chisq.test(ct[,-1],simulate.p.value = TRUE, B=10000)
  #ct <- 
  #print(ct)
  tibble(Size=unique(.x$Size),chi2=cc$statistic,pvalue = cc$p.value,method=cc$method)
  }) %>% arrange(desc(Size))  %>% mutate(meta="Lak")


# Add an asterisk to the significant ones
#
hc <- inner_join(hc, tt %>% select(Network,pvalue)) %>% mutate(net_name=if_else(pvalue<0.05, if_else(!grepl("Meta",Network), paste0(Network, ' *'),Network),Network)) %>% mutate(net_name=if_else(str_length(net_name)>18,str_sub(net_name,1,-6),net_name))


(gP2 <- ggplot(hc,aes(x=model,y=Freq,fill=type)) + 
  geom_bar(stat="identity", position=position_dodge()) + 
  scale_fill_brewer(palette = "Paired",name="") + 
  xlab("") + ylab("") + theme_bw() + 
    theme(legend.position=c(1,0), legend.justification=c(1,0), legend.direction="horizontal",   strip.background = element_blank(), strip.placement = "outside", axis.text.x = element_text(size=7)) + 
    facet_wrap(vars(fct_reorder(net_name, -Size))))
ggsave("Figures/Lak_TopoRoles_ByNetwork_Model.png",width=9,height=6,units="in",dpi=600)


topoRoles_metaWebAssembly_chi2 <- bind_rows(tt1,tt0,tt)
rm(tt,tt1,tt0,p)
save.image()

#
# Make a table
#

knitr::kable(topoRoles_metaWebAssembly_chi2%>% select( Network,meta,Size, chi2,pvalue),digits = 4)
topoRoles_metaWebAssembly_chi2 %>% summarize(sign = pvalue<0.05) %>% filter(sign, !grepl("Meta",Network)) 

```

* Most are not different from metaweb assembly model. Only 8 are significative at 5%